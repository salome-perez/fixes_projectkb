public class TSaslTransport {
    @Override
    public void open() throws TTransportException {
      /*
       * readSaslHeader is used to tag whether the SASL header has been read properly.
       * If there is a problem in reading the header, there might not be any
       * data in the stream, possibly a TCP health check from load balancer.
       */
      boolean readSaslHeader = false;
  
      LOGGER.debug("opening transport {}", this);
      if (sasl != null && sasl.isComplete())
        throw new TTransportException("SASL transport already open");
  
      if (!underlyingTransport.isOpen())
        underlyingTransport.open();
  
      try {
        // Negotiate a SASL mechanism. The client also sends its
        // initial response, or an empty one.
        handleSaslStartMessage();
        readSaslHeader = true;
        LOGGER.debug("{}: Start message handled", getRole());
  
        SaslResponse message = null;
        while (!sasl.isComplete()) {
          message = receiveSaslMessage();
          if (message.status != NegotiationStatus.COMPLETE &&
              message.status != NegotiationStatus.OK) {
            throw new TTransportException("Expected COMPLETE or OK, got " + message.status);
          }
  
          byte[] challenge = sasl.evaluateChallengeOrResponse(message.payload);
  
          // If we are the client, and the server indicates COMPLETE, we don't need to
          // send back any further response.
          if (message.status == NegotiationStatus.COMPLETE &&
              getRole() == SaslRole.CLIENT) {
            LOGGER.debug("{}: All done!", getRole());
            continue;
          }
  
          sendSaslMessage(sasl.isComplete() ? NegotiationStatus.COMPLETE : NegotiationStatus.OK,
                          challenge);
        }
        LOGGER.debug("{}: Main negotiation loop complete", getRole());
  
        // If we're the client, and we're complete, but the server isn't
        // complete yet, we need to wait for its response. This will occur
        // with ANONYMOUS auth, for example, where we send an initial response
        // and are immediately complete.
        if (getRole() == SaslRole.CLIENT &&
            (message == null || message.status == NegotiationStatus.OK)) {
          LOGGER.debug("{}: SASL Client receiving last message", getRole());
          message = receiveSaslMessage();
          if (message.status != NegotiationStatus.COMPLETE) {
            throw new TTransportException(
              "Expected SASL COMPLETE, but got " + message.status);
          }
        }
      } catch (SaslException e) {
        try {
          LOGGER.error("SASL negotiation failure", e);
          throw sendAndThrowMessage(NegotiationStatus.BAD, e.getMessage());
        } finally {
          underlyingTransport.close();
        }
      } catch (TTransportException e) {
        /*
         * If there is no-data or no-sasl header in the stream, throw a different
         * type of exception so we can handle this scenario differently.
         */
        if (!readSaslHeader && e.getType() == TTransportException.END_OF_FILE) {
          underlyingTransport.close();
          LOGGER.debug("No data or no sasl data in the stream");
          throw new TSaslTransportException("No data or no sasl data in the stream");
        }
        throw e;
      }
  
      String qop = (String) sasl.getNegotiatedProperty(Sasl.QOP);
      if (qop != null && !qop.equalsIgnoreCase("auth"))
        shouldWrap = true;
    }  
}