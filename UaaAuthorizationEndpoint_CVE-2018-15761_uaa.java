public class UaaAuthorizationEndpoint {
    @RequestMapping(value = "/oauth/authorize", method = RequestMethod.POST, params = OAuth2Utils.USER_OAUTH_APPROVAL)
    public View approveOrDeny(@RequestParam Map<String, String> approvalParameters, Map<String, ?> model,
                              SessionStatus sessionStatus, Principal principal) {

        if (!(principal instanceof Authentication)) {
            sessionStatus.setComplete();
            throw new InsufficientAuthenticationException(
              "User must be authenticated with Spring Security before authorizing an access token.");
        }

        AuthorizationRequest authorizationRequest = (AuthorizationRequest) model.get("authorizationRequest");

        if (authorizationRequest == null) {
            sessionStatus.setComplete();
            throw new InvalidRequestException("Cannot approve uninitialized authorization request.");
        }

        // Check to ensure the Authorization Request was not modified during the user approval step
        @SuppressWarnings("unchecked")
        Map<String, Object> originalAuthorizationRequest = (Map<String, Object>) model.get("org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint.ORIGINAL_AUTHORIZATION_REQUEST");
        if (isAuthorizationRequestModified(authorizationRequest, originalAuthorizationRequest)) {
            throw new InvalidRequestException("Changes were detected from the original authorization request.");
        }

        try {
            Set<String> responseTypes = authorizationRequest.getResponseTypes();
            String grantType = deriveGrantTypeFromResponseType(responseTypes);

            authorizationRequest.setApprovalParameters(approvalParameters);
            authorizationRequest = userApprovalHandler.updateAfterApproval(authorizationRequest,
              (Authentication) principal);
            boolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);
            authorizationRequest.setApproved(approved);

            if (authorizationRequest.getRedirectUri() == null) {
                sessionStatus.setComplete();
                throw new InvalidRequestException("Cannot approve request when no redirect URI is provided.");
            }

            if (!authorizationRequest.isApproved()) {
                return new RedirectView(getUnsuccessfulRedirect(authorizationRequest,
                  new UserDeniedAuthorizationException("User denied access"), responseTypes.contains("token")),
                  false, true, false);
            }

            if (responseTypes.contains("token") || responseTypes.contains("id_token")) {
                return getImplicitGrantOrHybridResponse(
                  authorizationRequest,
                  (Authentication) principal,
                  grantType
                ).getView();
            }

            return getAuthorizationCodeResponse(authorizationRequest, (Authentication) principal);
        } finally {
            sessionStatus.setComplete();
        }

    }

    public ModelAndView authorize(Map<String, Object> model,
                                  @RequestParam Map<String, String> parameters,
                                  SessionStatus sessionStatus,
                                  Principal principal,
                                  HttpServletRequest request) {

        ClientDetails client;
        String clientId;
        try {
            clientId = parameters.get("client_id");
            client = getClientServiceExtention().loadClientByClientId(clientId, IdentityZoneHolder.get().getId());
        } catch (NoSuchClientException x) {
            throw new InvalidClientException(x.getMessage());
        }

        // Pull out the authorization request first, using the OAuth2RequestFactory. All further logic should
        // query off of the authorization request instead of referring back to the parameters map. The contents of the
        // parameters map will be stored without change in the AuthorizationRequest object once it is created.
        AuthorizationRequest authorizationRequest;
        try {
            authorizationRequest = getOAuth2RequestFactory().createAuthorizationRequest(parameters);
        } catch (DisallowedIdpException x) {
            return switchIdp(model, client, clientId, request);
        }

        Set<String> responseTypes = authorizationRequest.getResponseTypes();
        String grantType = deriveGrantTypeFromResponseType(responseTypes);

        if (!supported_response_types.containsAll(responseTypes)) {
            throw new UnsupportedResponseTypeException("Unsupported response types: " + responseTypes);
        }

        if (authorizationRequest.getClientId() == null) {
            throw new InvalidClientException("A client id must be provided");
        }

        String resolvedRedirect = "";
        try {
            String redirectUriParameter = authorizationRequest.getRequestParameters().get(OAuth2Utils.REDIRECT_URI);
            try {
                resolvedRedirect = redirectResolver.resolveRedirect(redirectUriParameter, client);
            } catch (RedirectMismatchException rme) {
                throw new RedirectMismatchException(
                  "Invalid redirect " + redirectUriParameter + " did not match one of the registered values");
            }
            if (!StringUtils.hasText(resolvedRedirect)) {
                throw new RedirectMismatchException(
                  "A redirectUri must be either supplied or preconfigured in the ClientDetails");
            }

            boolean isAuthenticated = (principal instanceof Authentication) && ((Authentication) principal).isAuthenticated();

            if (!isAuthenticated) {
                throw new InsufficientAuthenticationException(
                  "User must be authenticated with Spring Security before authorization can be completed.");
            }

            if (!(responseTypes.size() > 0)) {
                return new ModelAndView(new RedirectView(addQueryParameter(addQueryParameter(resolvedRedirect, "error","invalid_request"), "error_description", "Missing response_type in authorization request")));
            }

            authorizationRequest.setRedirectUri(resolvedRedirect);
            // We intentionally only validate the parameters requested by the client (ignoring any data that may have
            // been added to the request by the manager).
            oauth2RequestValidator.validateScope(authorizationRequest, client);

            // Some systems may allow for approval decisions to be remembered or approved by default. Check for
            // such logic here, and set the approved flag on the authorization request accordingly.
            authorizationRequest = userApprovalHandler.checkForPreApproval(authorizationRequest,
              (Authentication) principal);
            boolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);
            authorizationRequest.setApproved(approved);

            // Validation is all done, so we can check for auto approval...
            if (authorizationRequest.isApproved()) {
                if (responseTypes.contains("token") || responseTypes.contains("id_token")) {
                    return getImplicitGrantOrHybridResponse(
                      authorizationRequest,
                      (Authentication) principal,
                      grantType
                    );
                }
                if (responseTypes.contains("code")) {
                    return new ModelAndView(getAuthorizationCodeResponse(authorizationRequest,
                      (Authentication) principal));
                }
            }


            if ("none".equals(authorizationRequest.getRequestParameters().get("prompt"))) {
                return new ModelAndView(
                  new RedirectView(addFragmentComponent(resolvedRedirect, "error=interaction_required"))
                );
            } else {
                // Place auth request into the model so that it is stored in the session
                // for approveOrDeny to use. That way we make sure that auth request comes from the session,
                // so any auth request parameters passed to approveOrDeny will be ignored and retrieved from the session.
                model.put("authorizationRequest", authorizationRequest);
                model.put("original_uri", UrlUtils.buildFullRequestUrl(request));
                model.put("org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint.ORIGINAL_AUTHORIZATION_REQUEST", unmodifiableMap(authorizationRequest));

                return getUserApprovalPageResponse(model, authorizationRequest, (Authentication) principal);
            }
        } catch (RedirectMismatchException e) {
            sessionStatus.setComplete();
            throw e;
        } catch (Exception e) {
            sessionStatus.setComplete();
            logger.debug("Unable to handle /oauth/authorize, internal error", e);
            if ("none".equals(authorizationRequest.getRequestParameters().get("prompt"))) {
                return new ModelAndView(
                  new RedirectView(addFragmentComponent(resolvedRedirect, "error=internal_server_error"))
                );
            }

            throw e;
        }

    }

}