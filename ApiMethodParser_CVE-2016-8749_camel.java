public class ApiMethodParser {
    public final List<ApiMethodModel> parse() {
        // parse sorted signatures and generate descriptions
        List<ApiMethodModel> result = new ArrayList<ApiMethodModel>();
        for (String signature : signatures) {

            // skip comment or empty lines
            if (signature.startsWith("##") || ObjectHelper.isEmpty(signature)) {
                continue;
            }

            // remove all modifiers and type parameters for method
            signature = signature.replaceAll(METHOD_PREFIX, "$4 $5(");
            // remove all final modifiers for arguments
            signature = signature.replaceAll("(\\(|,\\s*)final\\s+", "$1");
            // remove all redundant spaces in generic parameters
            signature = signature.replaceAll("\\s*<\\s*", "<").replaceAll("\\s*>", ">");

            log.debug("Processing " + signature);

            final Matcher methodMatcher = METHOD_PATTERN.matcher(signature);
            if (!methodMatcher.matches()) {
                throw new IllegalArgumentException("Invalid method signature " + signature);
            }

            // ignore generic type parameters in result, if any
            final Class<?> resultType = forName(methodMatcher.group(1));
            final String name = methodMatcher.group(3);
            final String argSignature = methodMatcher.group(4);

            final List<ApiMethodArg> arguments = new ArrayList<ApiMethodArg>();
            final List<Class<?>> argTypes = new ArrayList<Class<?>>();

            final Matcher argsMatcher = ARGS_PATTERN.matcher(argSignature);
            while (argsMatcher.find()) {

                final Class<?> type = forName(argsMatcher.group(1));
                argTypes.add(type);

                final String typeArgsGroup = argsMatcher.group(2);
                final String typeArgs = typeArgsGroup != null
                    ? typeArgsGroup.substring(1, typeArgsGroup.length() - 1).replaceAll(" ", "") : null;
                arguments.add(new ApiMethodArg(argsMatcher.group(3), type, typeArgs));
            }

            Method method;
            try {
                method = proxyType.getMethod(name, argTypes.toArray(new Class<?>[argTypes.size()]));
            } catch (NoSuchMethodException e) {
                throw new IllegalArgumentException("Method not found [" + signature + "] in type " + proxyType.getName());
            }
            result.add(new ApiMethodModel(name, resultType, arguments, method));
        }

        // allow derived classes to post process
        result = processResults(result);

        // check that argument names have the same type across methods
        Map<String, Class<?>> allArguments = new HashMap<String, Class<?>>();
        for (ApiMethodModel model : result) {
            for (ApiMethodArg argument : model.getArguments()) {
                String name = argument.getName();
                Class<?> argClass = allArguments.get(name);
                Class<?> type = argument.getType();
                if (argClass == null) {
                    allArguments.put(name, type);
                } else {
                    if (argClass != type) {
                        throw new IllegalArgumentException("Argument [" + name 
                                + "] is used in multiple methods with different types " 
                                + argClass.getCanonicalName() + ", " + type.getCanonicalName());
                    }
                }
            }
        }
        allArguments.clear();

        result.sort(new Comparator<ApiMethodModel>() {
            @Override
            public int compare(ApiMethodModel model1, ApiMethodModel model2) {
                final int nameCompare = model1.name.compareTo(model2.name);
                if (nameCompare != 0) {
                    return nameCompare;
                } else {

                    final int nArgs1 = model1.arguments.size();
                    final int nArgsCompare = nArgs1 - model2.arguments.size();
                    if (nArgsCompare != 0) {
                        return nArgsCompare;
                    } else {
                        // same number of args, compare arg names, kinda arbitrary to use alphabetized order
                        for (int i = 0; i < nArgs1; i++) {
                            final int argCompare = model1.arguments.get(i).getName().compareTo(model2.arguments.get(i).getName());
                            if (argCompare != 0) {
                                return argCompare;
                            }
                        }
                        // duplicate methods???
                        log.warn("Duplicate methods found [" + model1 + "], [" + model2 + "]");
                        return 0;
                    }
                }
            }
        });

        // assign unique names to every method model
        final Map<String, Integer> dups = new HashMap<String, Integer>();
        for (ApiMethodModel model : result) {
            // locale independent upper case conversion
            final String name = model.getName();
            final char[] upperCase = new char[name.length()];
            final char[] lowerCase = name.toCharArray();
            for (int i = 0; i < upperCase.length; i++) {
                upperCase[i] = Character.toUpperCase(lowerCase[i]);
            }
            String uniqueName = new String(upperCase);

            Integer suffix = dups.get(uniqueName);
            if (suffix == null) {
                dups.put(uniqueName, 1);
            } else {
                dups.put(uniqueName, suffix + 1);
                StringBuilder builder = new StringBuilder(uniqueName);
                builder.append("_").append(suffix);
                uniqueName = builder.toString();
            }
            model.uniqueName = uniqueName;
        }
        return result;
    }

}