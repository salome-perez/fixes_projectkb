public class StaticFileHandler {
    private void serveStatic(ChannelHandlerContext ctx, FullHttpRequest request, StaticFile staticFile)
            throws Exception {
        if (!request.decoderResult().isSuccess()) {
            sendError(ctx, BAD_REQUEST);
            return;
        }

        if (request.method() != HttpMethod.GET) {
            return;
        }

        Path path;
        String uri = request.uri();
        if (uri.contains("/..")) {
            sendError(ctx, NOT_FOUND);
            return;
        }
        //running from jar
        if (isUnpacked) {
            log.trace("Is unpacked.");
            if (staticFile instanceof StaticFileEdsWith) {
                StaticFileEdsWith staticFileEdsWith = (StaticFileEdsWith) staticFile;
                path = Paths.get(staticFileEdsWith.folderPathForStatic, uri);
            } else {
                path = Paths.get(jarPath, uri);
            }
        } else {
            //for local mode / running from ide
            path = FileUtils.getPathForLocalRun(uri);
        }

        log.trace("Getting file from path {}", path);

        if (path == null || Files.notExists(path) || Files.isDirectory(path)) {
            sendError(ctx, NOT_FOUND);
            return;
        }

        File file = path.toFile();

        // Cache Validation
        String ifModifiedSince = request.headers().get(IF_MODIFIED_SINCE);
        if (ifModifiedSince != null && !ifModifiedSince.isEmpty() && !(staticFile instanceof NoCacheStaticFile)) {
            SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
            Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);

            // Only compare up to the second because the datetime format we send to the client
            // does not have milliseconds
            long ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / 1000;
            long fileLastModifiedSeconds = file.lastModified() / 1000;
            if (ifModifiedSinceDateSeconds == fileLastModifiedSeconds) {
                sendNotModified(ctx);
                return;
            }
        }

        RandomAccessFile raf;
        try {
            raf = new RandomAccessFile(file, "r");
        } catch (FileNotFoundException ignore) {
            sendError(ctx, NOT_FOUND);
            return;
        }
        long fileLength = raf.length();

        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
        response.headers()
                .set(CONTENT_LENGTH, fileLength)
                .set(CONTENT_TYPE, ContentTypeUtil.getContentType(file.getName()))
                .set(ACCESS_CONTROL_ALLOW_ORIGIN, "*");

        //todo setup caching for files.
        setDateAndCacheHeaders(response, file);
        if (HttpUtil.isKeepAlive(request)) {
            response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
        }

        // Write the initial line and the header.
        ctx.write(response);

        // Write the content.
        ChannelFuture sendFileFuture;
        ChannelFuture lastContentFuture;
        if (ctx.pipeline().get(SslHandler.class) == null) {
            ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise());
            // Write the end marker.
            lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
        } else {
            sendFileFuture =
                    ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(raf, 128 * 1024)),
                            ctx.newProgressivePromise());
            // HttpChunkedInput will write the end marker (LastHttpContent) for us.
            lastContentFuture = sendFileFuture;
        }

        // Decide whether to close the connection or not.
        if (!HttpUtil.isKeepAlive(request)) {
            // Close the connection when the whole content is written out.
            lastContentFuture.addListener(ChannelFutureListener.CLOSE);
        }
    }

}