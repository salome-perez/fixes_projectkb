public class CertificateAuthorityCouncil {
  public List<Certificate> clean(List<Certificate> chain) throws SSLPeerUnverifiedException {
    Deque<Certificate> queue = new ArrayDeque<>(chain);
    List<Certificate> result = new ArrayList<>();
    result.add(queue.removeFirst());

    followIssuerChain:
    while (true) {
      X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);

      // If this cert has been signed by a trusted CA cert, we're done. Add the trusted CA
      // certificate to the end of the chain, unless it's already present. (That would happen if the
      // first certificate in the chain is itself a self-signed and trusted CA certificate.)
      X509Certificate caCert = trustRootIndex.findByIssuerAndSignature(toVerify);
      if (caCert != null) {
        if (result.size() > 1 || !toVerify.equals(caCert)) {
          result.add(caCert);
        }
        return result;
      }

      // Search for the certificate in the chain that signed this certificate. This is typically the
      // next element in the chain, but it could be any element.
      for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
        X509Certificate signingCert = (X509Certificate) i.next();
        if (toVerify.getIssuerDN().equals(signingCert.getSubjectDN())
            && verifySignature(toVerify, signingCert)) {
          i.remove();
          result.add(signingCert);
          continue followIssuerChain;
        }
      }

      throw new SSLPeerUnverifiedException("Failed to find a cert that signed " + toVerify);
    }
  }

  private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
    try {
      toVerify.verify(signingCert.getPublicKey());
      return true;
    } catch (GeneralSecurityException verifyFailed) {
      return false;
    }
  }

}