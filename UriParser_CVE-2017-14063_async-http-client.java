public class UriParser {
    private boolean computeQuery() {
        if (currentIndex < end) {
            int askPosition = findWithinCurrentRange('?');
            if (askPosition != -1) {
                query = originalUrl.substring(askPosition + 1, end);
                if (end > askPosition) {
                    end = askPosition;
                }
                return askPosition == currentIndex;
            }
        }
        return false;
    }

    private void removeTrailingDot() {
        if (path.endsWith("/.")) {
            path = path.substring(0, path.length() - 1);
        }
    }

    private void removeEmbedded2Dots() {
        int i = 0;
        while ((i = path.indexOf("/../", i)) >= 0) {
            if (i > 0) {
                end = path.lastIndexOf('/', i - 1);
                if (end >= 0 && path.indexOf("/../", end) != 0) {
                    path = path.substring(0, end) + path.substring(i + 3);
                    i = 0;
                } else if (end == 0) {
                    break;
                }
            } else {
                i = i + 3;
            }
        }
    }

    private boolean isValidProtocolChars(String protocol) {
        for (int i = 1; i < protocol.length(); i++) {
            if (!isValidProtocolChar(protocol.charAt(i))) {
                return false;
            }
        }
        return true;
    }

    private void trimLeft() {
        while (start < end && originalUrl.charAt(start) <= ' ') {
            start++;
        }

        if (originalUrl.regionMatches(true, start, "url:", 0, 4)) {
            start += 4;
        }
    }

    private void removeTailing2Dots() {
        while (path.endsWith("/..")) {
            end = path.lastIndexOf('/', path.length() - 4);
            if (end >= 0) {
                path = path.substring(0, end + 1);
            } else {
                break;
            }
        }
    }

    private void computeIPV6() {
        int positionAfterClosingSquareBrace = host.indexOf(']') + 1;
        if (positionAfterClosingSquareBrace > 1) {

            port = -1;

            if (host.length() > positionAfterClosingSquareBrace) {
                if (host.charAt(positionAfterClosingSquareBrace) == ':') {
                    // see RFC2396: port can be null
                    int portPosition = positionAfterClosingSquareBrace + 1;
                    if (host.length() > portPosition) {
                        port = Integer.parseInt(host.substring(portPosition));
                    }
                } else {
                    throw new IllegalArgumentException("Invalid authority field: " + authority);
                }
            }

            host = host.substring(0, positionAfterClosingSquareBrace);

        } else {
            throw new IllegalArgumentException("Invalid authority field: " + authority);
        }
    }

    private void computeInitialScheme() {
        for (int i = currentIndex; i < end; i++) {
            char c = originalUrl.charAt(i);
            if (c == ':') {
                String s = originalUrl.substring(currentIndex, i);
                if (isValidProtocol(s)) {
                    scheme = s.toLowerCase();
                    currentIndex = i + 1;
                }
                break;
            } else if (c == '/') {
                break;
            }
        }
    }

    private boolean isFragmentOnly() {
        return start < originalUrl.length() && originalUrl.charAt(start) == '#';
    }

    private void handleRelativePath() {
        int lastSlashPosition = path.lastIndexOf('/');
        String pathEnd = originalUrl.substring(currentIndex, end);

        if (lastSlashPosition == -1) {
            path = authority != null ? "/" + pathEnd : pathEnd;
        } else {
            path = path.substring(0, lastSlashPosition + 1) + pathEnd;
        }
    }

    public void parse(Uri context, final String originalUrl) {

        assertNotNull(originalUrl, "orginalUri");
        this.originalUrl = originalUrl;
        this.end = originalUrl.length();

        trimLeft();
        trimRight();
        currentIndex = start;
        if (!isFragmentOnly()) {
            computeInitialScheme();
        }
        boolean isRelative = overrideWithContext(context);
        trimFragment();
        inheritContextQuery(context, isRelative);
        boolean queryOnly = computeQuery();
        parseAuthority();
        computePath(queryOnly);
    }

    private void trimRight() {
        end = originalUrl.length();
        while (end > 0 && originalUrl.charAt(end - 1) <= ' ') {
            end--;
        }
    }

    private void computeUserInfo() {
        int atPosition = authority.indexOf('@');
        if (atPosition != -1) {
            userInfo = authority.substring(0, atPosition);
            host = authority.substring(atPosition + 1);
        } else {
            userInfo = null;
        }
    }

    private void parseAuthority() {
        if (!currentPositionStartsWith4Slashes() && currentPositionStartsWith2Slashes()) {
            currentIndex += 2;

            computeAuthority();
            computeUserInfo();

            if (host != null) {
                if (isMaybeIPV6()) {
                    computeIPV6();
                } else {
                    computeRegularHostPort();
                }
            }

            if (port < -1) {
                throw new IllegalArgumentException("Invalid port number :" + port);
            }

            // see RFC2396 5.2.4: ignore context path if authority is defined
            if (isNonEmpty(authority)) {
                path = "";
            }
        }
    }

    private int findWithinCurrentRange(char c) {
        int pos = originalUrl.indexOf(c, currentIndex);
        return pos > end ? -1 : pos;
    }

    private void removeStartingDot() {
        if (path.startsWith("./") && path.length() > 2) {
            path = path.substring(2);
        }
    }

    private void computeAuthority() {
        int authorityEndPosition = findWithinCurrentRange('/');
        if (authorityEndPosition == -1) {
            authorityEndPosition = findWithinCurrentRange('?');
            if (authorityEndPosition == -1) {
                authorityEndPosition = end;
            }
        }
        host = authority = originalUrl.substring(currentIndex, authorityEndPosition);
        currentIndex = authorityEndPosition;
    }

    private void computePath(boolean queryOnly) {
        // Parse the file path if any
        if (currentIndex < end) {
            computeRegularPath();
        } else if (queryOnly && path != null) {
            computeQueryOnlyPath();
        } else if (path == null) {
            path = "";
        }
    }

    private boolean overrideWithContext(Uri context) {

        boolean isRelative = false;

        // use context only if schemes match
        if (context != null && (scheme == null || scheme.equalsIgnoreCase(context.getScheme()))) {

            // see RFC2396 5.2.3
            String contextPath = context.getPath();
            if (isNonEmpty(contextPath) && contextPath.charAt(0) == '/') {
                scheme = null;
            }

            if (scheme == null) {
                scheme = context.getScheme();
                userInfo = context.getUserInfo();
                host = context.getHost();
                port = context.getPort();
                path = contextPath;
                isRelative = true;
            }
        }
        return isRelative;
    }

    private void computeRegularPath() {
        if (originalUrl.charAt(currentIndex) == '/') {
            path = originalUrl.substring(currentIndex, end);
        } else if (isNonEmpty(path)) {
            handleRelativePath();
        } else {
            String pathEnd = originalUrl.substring(currentIndex, end);
            path = isNonEmpty(pathEnd) && pathEnd.charAt(0) != '/' ? "/" + pathEnd : pathEnd;
        }
        handlePathDots();
    }

    private void inheritContextQuery(Uri context, boolean isRelative) {
        // see RFC2396 5.2.2: query and fragment inheritance
        if (isRelative && currentIndex == end) {
            query = context.getQuery();
        }
    }

}