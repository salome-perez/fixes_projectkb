public class AmbariServer {
    @SuppressWarnings("deprecation")
    public void run() throws Exception {
      performStaticInjection();
      initDB();
      server = new Server();
      server.setSessionIdManager(sessionIdManager);
      Server serverForAgent = new Server();
  
      DatabaseChecker.checkDBVersion();
      DatabaseChecker.checkDBConsistency();
  
      try {
        ClassPathXmlApplicationContext parentSpringAppContext =
            new ClassPathXmlApplicationContext();
        parentSpringAppContext.refresh();
        ConfigurableListableBeanFactory factory = parentSpringAppContext.
            getBeanFactory();
        factory.registerSingleton("guiceInjector",
            injector);
        factory.registerSingleton("passwordEncoder",
            injector.getInstance(PasswordEncoder.class));
        factory.registerSingleton("ambariLocalUserService",
            injector.getInstance(AmbariLocalUserDetailsService.class));
        factory.registerSingleton("ambariLdapAuthenticationProvider",
            injector.getInstance(AmbariLdapAuthenticationProvider.class));
        factory.registerSingleton("ambariLdapDataPopulator",
            injector.getInstance(AmbariLdapDataPopulator.class));
        factory.registerSingleton("ambariAuthorizationFilter",
            injector.getInstance(AmbariAuthorizationFilter.class));
        factory.registerSingleton("ambariInternalAuthenticationProvider",
            injector.getInstance(AmbariInternalAuthenticationProvider.class));
  
        //Spring Security xml config depends on this Bean
  
        String[] contextLocations = {SPRING_CONTEXT_LOCATION};
        ClassPathXmlApplicationContext springAppContext = new
            ClassPathXmlApplicationContext(contextLocations, parentSpringAppContext);
        //setting ambari web context
  
        ServletContextHandler root = new ServletContextHandler(
            ServletContextHandler.SECURITY | ServletContextHandler.SESSIONS);
  
        configureRootHandler(root);
        configureSessionManager(sessionManager);
        root.getSessionHandler().setSessionManager(sessionManager);
  
        GenericWebApplicationContext springWebAppContext = new GenericWebApplicationContext();
        springWebAppContext.setServletContext(root.getServletContext());
        springWebAppContext.setParent(springAppContext);
  
        root.getServletContext().setAttribute(
            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,
            springWebAppContext);
  
        certMan.initRootCert();
  
        // the agent communication (heartbeats, registration, etc) is stateless
        // and does not use sessions.
        ServletContextHandler agentroot = new ServletContextHandler(
            serverForAgent, "/", ServletContextHandler.NO_SESSIONS);
        if (configs.isAgentApiGzipped()) {
          configureHandlerCompression(agentroot);
        }
  
        ServletHolder rootServlet = root.addServlet(DefaultServlet.class, "/");
        rootServlet.setInitParameter("dirAllowed", "false");
        rootServlet.setInitOrder(1);
  
        /* Configure default servlet for agent server */
        rootServlet = agentroot.addServlet(DefaultServlet.class, "/");
        rootServlet.setInitOrder(1);
  
        //session-per-request strategy for api and agents
        root.addFilter(new FilterHolder(injector.getInstance(AmbariPersistFilter.class)), "/api/*", DISPATCHER_TYPES);
        // root.addFilter(new FilterHolder(injector.getInstance(AmbariPersistFilter.class)), "/proxy/*", DISPATCHER_TYPES);
        root.addFilter(new FilterHolder(new MethodOverrideFilter()), "/api/*", DISPATCHER_TYPES);
        // root.addFilter(new FilterHolder(new MethodOverrideFilter()), "/proxy/*", DISPATCHER_TYPES);
  
        // register listener to capture request context
        root.addEventListener(new RequestContextListener());
  
        agentroot.addFilter(new FilterHolder(injector.getInstance(AmbariPersistFilter.class)), "/agent/*", DISPATCHER_TYPES);
        agentroot.addFilter(SecurityFilter.class, "/*", DISPATCHER_TYPES);
  
        if (configs.getApiAuthentication()) {
          root.addFilter(new FilterHolder(springSecurityFilter), "/api/*", DISPATCHER_TYPES);
        // root.addFilter(new FilterHolder(springSecurityFilter), "/proxy/*", DISPATCHER_TYPES);
        }
  
  
        //Secured connector for 2-way auth
        SslContextFactory contextFactoryTwoWay = new SslContextFactory();
        disableInsecureProtocols(contextFactoryTwoWay);
        SslSelectChannelConnector sslConnectorTwoWay = new
            SslSelectChannelConnector(contextFactoryTwoWay);
        sslConnectorTwoWay.setPort(configs.getTwoWayAuthPort());
  
        Map<String, String> configsMap = configs.getConfigsMap();
        String keystore = configsMap.get(Configuration.SRVR_KSTR_DIR_KEY) +
            File.separator + configsMap.get(Configuration.KSTR_NAME_KEY);
        String srvrCrtPass = configsMap.get(Configuration.SRVR_CRT_PASS_KEY);
        sslConnectorTwoWay.setKeystore(keystore);
        sslConnectorTwoWay.setTruststore(keystore);
        sslConnectorTwoWay.setPassword(srvrCrtPass);
        sslConnectorTwoWay.setKeyPassword(srvrCrtPass);
        sslConnectorTwoWay.setTrustPassword(srvrCrtPass);
        sslConnectorTwoWay.setKeystoreType("PKCS12");
        sslConnectorTwoWay.setTruststoreType("PKCS12");
        sslConnectorTwoWay.setNeedClientAuth(configs.getTwoWaySsl());
  
        //SSL Context Factory
        SslContextFactory contextFactoryOneWay = new SslContextFactory(true);
        contextFactoryOneWay.setKeyStorePath(keystore);
        contextFactoryOneWay.setTrustStore(keystore);
        contextFactoryOneWay.setKeyStorePassword(srvrCrtPass);
        contextFactoryOneWay.setKeyManagerPassword(srvrCrtPass);
        contextFactoryOneWay.setTrustStorePassword(srvrCrtPass);
        contextFactoryOneWay.setKeyStoreType("PKCS12");
        contextFactoryOneWay.setTrustStoreType("PKCS12");
        contextFactoryOneWay.setNeedClientAuth(false);
        disableInsecureProtocols(contextFactoryOneWay);
  
        //Secured connector for 1-way auth
        SslSelectChannelConnector sslConnectorOneWay = new SslSelectChannelConnector(contextFactoryOneWay);
        sslConnectorOneWay.setPort(configs.getOneWayAuthPort());
        sslConnectorOneWay.setAcceptors(2);
        sslConnectorTwoWay.setAcceptors(2);
        serverForAgent.setConnectors(new Connector[]{sslConnectorOneWay, sslConnectorTwoWay});
  
        ServletHolder sh = new ServletHolder(ServletContainer.class);
        sh.setInitParameter("com.sun.jersey.config.property.resourceConfigClass",
            "com.sun.jersey.api.core.PackagesResourceConfig");
        sh.setInitParameter("com.sun.jersey.config.property.packages",
            "org.apache.ambari.server.api.rest;" +
                "org.apache.ambari.server.api.services;" +
                "org.apache.ambari.eventdb.webservice;" +
                "org.apache.ambari.server.api");
        sh.setInitParameter("com.sun.jersey.api.json.POJOMappingFeature",
            "true");
        root.addServlet(sh, "/api/v1/*");
        sh.setInitOrder(2);
  
        SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);
  
        viewRegistry.readViewArchives();
  
        handlerList.addHandler(root);
  
        server.setHandler(handlerList);
  
        ServletHolder agent = new ServletHolder(ServletContainer.class);
        agent.setInitParameter("com.sun.jersey.config.property.resourceConfigClass",
            "com.sun.jersey.api.core.PackagesResourceConfig");
        agent.setInitParameter("com.sun.jersey.config.property.packages",
            "org.apache.ambari.server.agent.rest;" + "org.apache.ambari.server.api");
        agent.setInitParameter("com.sun.jersey.api.json.POJOMappingFeature",
            "true");
        agentroot.addServlet(agent, "/agent/v1/*");
        agent.setInitOrder(3);
  
        ServletHolder cert = new ServletHolder(ServletContainer.class);
        cert.setInitParameter("com.sun.jersey.config.property.resourceConfigClass",
            "com.sun.jersey.api.core.PackagesResourceConfig");
        cert.setInitParameter("com.sun.jersey.config.property.packages",
            "org.apache.ambari.server.security.unsecured.rest;" + "org.apache.ambari.server.api");
        cert.setInitParameter("com.sun.jersey.api.json.POJOMappingFeature",
            "true");
        agentroot.addServlet(cert, "/*");
        cert.setInitOrder(4);
  
        /*
        ServletHolder proxy = new ServletHolder(ServletContainer.class);
        proxy.setInitParameter("com.sun.jersey.config.property.resourceConfigClass",
                               "com.sun.jersey.api.core.PackagesResourceConfig");
        proxy.setInitParameter("com.sun.jersey.config.property.packages",
                               "org.apache.ambari.server.proxy");
        proxy.setInitParameter("com.sun.jersey.api.json.POJOMappingFeature", "true");
        root.addServlet(proxy, "/proxy/*");
        proxy.setInitOrder(5);
        */
  
        ServletHolder resources = new ServletHolder(ServletContainer.class);
        resources.setInitParameter("com.sun.jersey.config.property.resourceConfigClass",
            "com.sun.jersey.api.core.PackagesResourceConfig");
        resources.setInitParameter("com.sun.jersey.config.property.packages",
            "org.apache.ambari.server.resources.api.rest;");
        root.addServlet(resources, "/resources/*");
        resources.setInitOrder(5);
  
        if (configs.csrfProtectionEnabled()) {
          sh.setInitParameter("com.sun.jersey.spi.container.ContainerRequestFilters",
                      "org.apache.ambari.server.api.AmbariCsrfProtectionFilter");
          /* proxy.setInitParameter("com.sun.jersey.spi.container.ContainerRequestFilters",
                      "org.apache.ambari.server.api.AmbariCsrfProtectionFilter"); */
        }
  
        // Set jetty thread pool
        QueuedThreadPool qtp = new QueuedThreadPool(configs.getAgentThreadPoolSize());
        qtp.setName("qtp-ambari-agent");
        serverForAgent.setThreadPool(qtp);
  
        qtp = new QueuedThreadPool(configs.getClientThreadPoolSize());
        qtp.setName("qtp-client");
        server.setThreadPool(qtp);
  
        /* Configure the API server to use the NIO connectors */
        SelectChannelConnector apiConnector;
  
        if (configs.getApiSSLAuthentication()) {
          String httpsKeystore = configsMap.get(Configuration.CLIENT_API_SSL_KSTR_DIR_NAME_KEY) +
            File.separator + configsMap.get(Configuration.CLIENT_API_SSL_KSTR_NAME_KEY);
          LOG.info("API SSL Authentication is turned on. Keystore - " + httpsKeystore);
  
          String httpsCrtPass = configsMap.get(Configuration.CLIENT_API_SSL_CRT_PASS_KEY);
  
          SslContextFactory contextFactoryApi = new SslContextFactory();
          disableInsecureProtocols(contextFactoryApi);
          SslSelectChannelConnector sapiConnector = new SslSelectChannelConnector(contextFactoryApi);
          sapiConnector.setPort(configs.getClientSSLApiPort());
          sapiConnector.setKeystore(httpsKeystore);
          sapiConnector.setTruststore(httpsKeystore);
          sapiConnector.setPassword(httpsCrtPass);
          sapiConnector.setKeyPassword(httpsCrtPass);
          sapiConnector.setTrustPassword(httpsCrtPass);
          sapiConnector.setKeystoreType("PKCS12");
          sapiConnector.setTruststoreType("PKCS12");
          sapiConnector.setMaxIdleTime(configs.getConnectionMaxIdleTime());
          apiConnector = sapiConnector;
        }
        else  {
          apiConnector = new SelectChannelConnector();
          apiConnector.setPort(configs.getClientApiPort());
          apiConnector.setMaxIdleTime(configs.getConnectionMaxIdleTime());
        }
  
        server.addConnector(apiConnector);
  
        server.setStopAtShutdown(true);
        serverForAgent.setStopAtShutdown(true);
        springAppContext.start();
  
        String osType = getServerOsType();
        if (osType == null || osType.isEmpty()) {
          throw new RuntimeException(Configuration.OS_VERSION_KEY + " is not "
              + " set in the ambari.properties file");
        }
  
        //Start action scheduler
        LOG.info("********* Initializing Clusters **********");
        Clusters clusters = injector.getInstance(Clusters.class);
        StringBuilder clusterDump = new StringBuilder();
        clusters.debugDump(clusterDump);
        LOG.info("********* Current Clusters State *********");
        LOG.info(clusterDump.toString());
  
        LOG.info("********* Reconciling Alert Definitions **********");
        ambariMetaInfo.reconcileAlertDefinitions(clusters);
  
        LOG.info("********* Initializing ActionManager **********");
        ActionManager manager = injector.getInstance(ActionManager.class);
        LOG.info("********* Initializing Controller **********");
        AmbariManagementController controller = injector.getInstance(
            AmbariManagementController.class);
  
        LOG.info("********* Initializing Scheduled Request Manager **********");
        ExecutionScheduleManager executionScheduleManager = injector
          .getInstance(ExecutionScheduleManager.class);
  
  
        clusterController = controller;
  
        StateRecoveryManager recoveryManager = injector.getInstance(
                StateRecoveryManager.class);
        recoveryManager.doWork();
  
        /*
         * Start the server after controller state is recovered.
         */
        server.start();
  
        serverForAgent.start();
        LOG.info("********* Started Server **********");
  
        manager.start();
        LOG.info("********* Started ActionManager **********");
  
        executionScheduleManager.start();
        LOG.info("********* Started Scheduled Request Manager **********");
  
        serviceManager.startAsync();
        LOG.info("********* Started Services **********");
  
        server.join();
        LOG.info("Joined the Server");
      } catch (BadPaddingException bpe){
        LOG.error("Bad keystore or private key password. " +
          "HTTPS certificate re-importing may be required.");
        throw bpe;
      } catch(BindException bindException) {
        LOG.error("Could not bind to server port - instance may already be running. " +
            "Terminating this instance.", bindException);
        throw bindException;
      }
    }
}