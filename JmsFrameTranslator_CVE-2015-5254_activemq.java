public class JmsFrameTranslator {
    public ActiveMQMessage convertFrame(ProtocolConverter converter, StompFrame command) throws JMSException, ProtocolException {
        Map<String, String> headers = command.getHeaders();
        ActiveMQMessage msg;
        String transformation = headers.get(Headers.TRANSFORMATION);
        if (headers.containsKey(Headers.CONTENT_LENGTH) || transformation.equals(Transformations.JMS_BYTE.toString())) {
            msg = super.convertFrame(converter, command);
        } else {
            HierarchicalStreamReader in;

            try {
                String text = new String(command.getContent(), "UTF-8");
                switch (Transformations.getValue(transformation)) {
                    case JMS_OBJECT_XML:
                        in = new XppReader(new StringReader(text), XppFactory.createDefaultParser());
                        msg = createObjectMessage(in);
                        break;
                    case JMS_OBJECT_JSON:
                        in = new JettisonMappedXmlDriver().createReader(new StringReader(text));
                        msg = createObjectMessage(in);
                        break;
                    case JMS_MAP_XML:
                        in = new XppReader(new StringReader(text), XppFactory.createDefaultParser());
                        msg = createMapMessage(in);
                        break;
                    case JMS_MAP_JSON:
                        in = new JettisonMappedXmlDriver().createReader(new StringReader(text));
                        msg = createMapMessage(in);
                        break;
                    default:
                        throw new Exception("Unknown transformation: " + transformation);
                }
            } catch (Throwable e) {
                command.getHeaders().put(Headers.TRANSFORMATION_ERROR, e.getMessage());
                msg = super.convertFrame(converter, command);
            }
        }

        copyStandardHeadersFromFrameToMessage(converter, command, msg, this);
        return msg;
    }

    @SuppressWarnings("unchecked")
    protected XStream createXStream() {
        XStream xstream = null;
        if (brokerContext != null) {
            Map<String, XStream> beans = brokerContext.getBeansOfType(XStream.class);
            for (XStream bean : beans.values()) {
                if (bean != null) {
                    xstream = bean;
                    break;
                }
            }
        }

        if (xstream == null) {
            xstream = XStreamSupport.createXStream();
            xstream.ignoreUnknownElements();
        }

        // For any object whose elements contains an UTF8Buffer instance instead
        // of a String type we map it to String both in and out such that we don't
        // marshal UTF8Buffers out
        xstream.registerConverter(new AbstractSingleValueConverter() {

            @Override
            public Object fromString(String str) {
                return str;
            }

            @SuppressWarnings("rawtypes")
            @Override
            public boolean canConvert(Class type) {
                return type.equals(UTF8Buffer.class);
            }
        });

        xstream.alias("string", UTF8Buffer.class);

        return xstream;
    }

}