public class CachedStore {
  @Override
  public void alterTable(String dbName, String tblName, Table newTable)
      throws InvalidObjectException, MetaException {
    rawStore.alterTable(dbName, tblName, newTable);
    dbName = StringUtils.normalizeIdentifier(dbName);
    tblName = StringUtils.normalizeIdentifier(tblName);
    String newTblName = StringUtils.normalizeIdentifier(newTable.getTableName());
    if (!shouldCacheTable(dbName, tblName) && !shouldCacheTable(dbName, newTblName)) {
      return;
    }
    SharedCache sharedCache = sharedCacheWrapper.get();
    if (sharedCache == null) {
      return;
    }

    if (shouldCacheTable(dbName, newTblName)) {
      validateTableType(newTable);
      // Update table cache
      try {
        // Wait if background cache update is happening
        tableCacheLock.readLock().lock();
        isTableCacheDirty.set(true);
        sharedCache.alterTableInCache(StringUtils.normalizeIdentifier(dbName),
            StringUtils.normalizeIdentifier(tblName), newTable);
      } finally {
        tableCacheLock.readLock().unlock();
      }
      // Update partition cache (key might have changed since table name is a
      // component of key)
      try {
        // Wait if background cache update is happening
        partitionCacheLock.readLock().lock();
        isPartitionCacheDirty.set(true);
        sharedCache.alterTableInPartitionCache(StringUtils.normalizeIdentifier(dbName),
            StringUtils.normalizeIdentifier(tblName), newTable);
      } finally {
        partitionCacheLock.readLock().unlock();
      }
    } else {
      // Remove the table and its cached partitions, stats etc,
      // since it does not pass the whitelist/blacklist filter.
      // Remove table
      try {
        // Wait if background cache update is happening
        tableCacheLock.readLock().lock();
        isTableCacheDirty.set(true);
        sharedCache.removeTableFromCache(dbName, tblName);
      } finally {
        tableCacheLock.readLock().unlock();
      }
      // Remove partitions
      try {
        // Wait if background cache update is happening
        partitionCacheLock.readLock().lock();
        isPartitionCacheDirty.set(true);
        sharedCache.removePartitionsFromCache(dbName, tblName);
      } finally {
        partitionCacheLock.readLock().unlock();
      }
      // Remove partition col stats
      try {
        // Wait if background cache update is happening
        partitionColStatsCacheLock.readLock().lock();
        isPartitionColStatsCacheDirty.set(true);
        sharedCache.removePartitionColStatsFromCache(dbName, tblName);
      } finally {
        partitionColStatsCacheLock.readLock().unlock();
      }
      // Update aggregate partition col stats keys wherever applicable
      try {
        // Wait if background cache update is happening
        partitionAggrColStatsCacheLock.readLock().lock();
        isPartitionAggrColStatsCacheDirty.set(true);
        sharedCache.alterTableInAggrPartitionColStatsCache(dbName, tblName, newTable);
      } finally {
        partitionAggrColStatsCacheLock.readLock().unlock();
      }
    }
  }

    public SharedCache get() throws MetaException {
      if (!waitForInit()) {
        return null;
      }
      return instance;
    }

  @Override
  public void createTable(Table tbl) throws InvalidObjectException, MetaException {
    rawStore.createTable(tbl);
    String dbName = StringUtils.normalizeIdentifier(tbl.getDbName());
    String tblName = StringUtils.normalizeIdentifier(tbl.getTableName());
    if (!shouldCacheTable(dbName, tblName)) {
      return;
    }
    SharedCache sharedCache = sharedCacheWrapper.get();
    if (sharedCache == null) {
      return;
    }
    validateTableType(tbl);
    try {
      // Wait if background cache update is happening
      tableCacheLock.readLock().lock();
      isTableCacheDirty.set(true);
      sharedCache.addTableToCache(dbName, tblName, tbl);
    } finally {
      tableCacheLock.readLock().unlock();
    }
  }

  private static List<String> partNameToVals(String name) {
    if (name == null) {
      return null;
    }
    List<String> vals = new ArrayList<>();
    String[] kvp = name.split("/");
    for (String kv : kvp) {
      vals.add(FileUtils.unescapePathName(kv.substring(kv.indexOf('=') + 1)));
    }
    return vals;
  }

  @Override
  public boolean alterDatabase(String dbName, Database db) throws NoSuchObjectException,
      MetaException {
    boolean succ = rawStore.alterDatabase(dbName, db);
    if (succ) {
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      try {
        // Wait if background cache update is happening
        databaseCacheLock.readLock().lock();
        isDatabaseCacheDirty.set(true);
        sharedCache.alterDatabaseInCache(StringUtils.normalizeIdentifier(dbName), db);
      } finally {
        databaseCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public void alterPartition(String dbName, String tblName, List<String> partVals, Partition newPart)
      throws InvalidObjectException, MetaException {
    rawStore.alterPartition(dbName, tblName, partVals, newPart);
    dbName = StringUtils.normalizeIdentifier(dbName);
    tblName = StringUtils.normalizeIdentifier(tblName);
    if (!shouldCacheTable(dbName, tblName)) {
      return;
    }
    SharedCache sharedCache = sharedCacheWrapper.get();
    if (sharedCache == null) {
      return;
    }
    // Update partition cache
    try {
      // Wait if background cache update is happening
      partitionCacheLock.readLock().lock();
      isPartitionCacheDirty.set(true);
      sharedCache.alterPartitionInCache(dbName, tblName, partVals, newPart);
    } finally {
      partitionCacheLock.readLock().unlock();
    }
    // Update partition column stats cache
    try {
      // Wait if background cache update is happening
      partitionColStatsCacheLock.readLock().lock();
      isPartitionColStatsCacheDirty.set(true);
      sharedCache.alterPartitionInColStatsCache(dbName, tblName, partVals, newPart);
    } finally {
      partitionColStatsCacheLock.readLock().unlock();
    }
    // Remove aggregate partition col stats for this table
    try {
      // Wait if background cache update is happening
      partitionAggrColStatsCacheLock.readLock().lock();
      isPartitionAggrColStatsCacheDirty.set(true);
      sharedCache.removeAggrPartitionColStatsFromCache(dbName, tblName);
    } finally {
      partitionAggrColStatsCacheLock.readLock().unlock();
    }
  }

  @Override
  public List<String> createTableWithConstraints(Table tbl, List<SQLPrimaryKey> primaryKeys,
      List<SQLForeignKey> foreignKeys, List<SQLUniqueConstraint> uniqueConstraints,
      List<SQLNotNullConstraint> notNullConstraints,
      List<SQLDefaultConstraint> defaultConstraints) throws InvalidObjectException, MetaException {
    // TODO constraintCache
    List<String> constraintNames = rawStore.createTableWithConstraints(tbl, primaryKeys,
        foreignKeys, uniqueConstraints, notNullConstraints, defaultConstraints);
    String dbName = StringUtils.normalizeIdentifier(tbl.getDbName());
    String tblName = StringUtils.normalizeIdentifier(tbl.getTableName());
    if (!shouldCacheTable(dbName, tblName)) {
      return constraintNames;
    }
    SharedCache sharedCache = sharedCacheWrapper.get();
    if (sharedCache == null) {
      return constraintNames;
    }
    sharedCache.addTableToCache(StringUtils.normalizeIdentifier(tbl.getDbName()),
        StringUtils.normalizeIdentifier(tbl.getTableName()), tbl);
    return constraintNames;
  }

  @Override
  public boolean addPartitions(String dbName, String tblName, PartitionSpecProxy partitionSpec,
      boolean ifNotExists) throws InvalidObjectException, MetaException {
    boolean succ = rawStore.addPartitions(dbName, tblName, partitionSpec, ifNotExists);
    if (succ) {
      dbName = StringUtils.normalizeIdentifier(dbName);
      tblName = StringUtils.normalizeIdentifier(tblName);
      if (!shouldCacheTable(dbName, tblName)) {
        return succ;
      }
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      try {
        // Wait if background cache update is happening
        partitionCacheLock.readLock().lock();
        isPartitionCacheDirty.set(true);
        PartitionSpecProxy.PartitionIterator iterator = partitionSpec.getPartitionIterator();
        while (iterator.hasNext()) {
          Partition part = iterator.next();
          sharedCache.addPartitionToCache(dbName, tblName, part);
        }
      } finally {
        partitionCacheLock.readLock().unlock();
      }
      // Remove aggregate partition col stats for this table
      try {
        // Wait if background cache update is happening
        partitionAggrColStatsCacheLock.readLock().lock();
        isPartitionAggrColStatsCacheDirty.set(true);
        sharedCache.removeAggrPartitionColStatsFromCache(dbName, tblName);
      } finally {
        partitionAggrColStatsCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public boolean updateTableColumnStatistics(ColumnStatistics colStats)
      throws NoSuchObjectException, MetaException, InvalidObjectException, InvalidInputException {
    boolean succ = rawStore.updateTableColumnStatistics(colStats);
    if (succ) {
      String dbName = StringUtils.normalizeIdentifier(colStats.getStatsDesc().getDbName());
      String tblName = StringUtils.normalizeIdentifier(colStats.getStatsDesc().getTableName());
      if (!shouldCacheTable(dbName, tblName)) {
        return succ;
      }
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      List<ColumnStatisticsObj> statsObjs = colStats.getStatsObj();
      Table tbl = getTable(dbName, tblName);
      List<String> colNames = new ArrayList<>();
      for (ColumnStatisticsObj statsObj : statsObjs) {
        colNames.add(statsObj.getColName());
      }
      StatsSetupConst.setColumnStatsState(tbl.getParameters(), colNames);
      // Update table
      try {
        // Wait if background cache update is happening
        tableCacheLock.readLock().lock();
        isTableCacheDirty.set(true);
        sharedCache.alterTableInCache(dbName, tblName, tbl);
      } finally {
        tableCacheLock.readLock().unlock();
      }
      // Update table col stats
      try {
        // Wait if background cache update is happening
        tableColStatsCacheLock.readLock().lock();
        isTableColStatsCacheDirty.set(true);
        sharedCache.updateTableColStatsInCache(dbName, tblName, statsObjs);
      } finally {
        tableColStatsCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public void alterPartitions(String dbName, String tblName, List<List<String>> partValsList,
      List<Partition> newParts) throws InvalidObjectException, MetaException {
    rawStore.alterPartitions(dbName, tblName, partValsList, newParts);
    dbName = StringUtils.normalizeIdentifier(dbName);
    tblName = StringUtils.normalizeIdentifier(tblName);
    if (!shouldCacheTable(dbName, tblName)) {
      return;
    }
    SharedCache sharedCache = sharedCacheWrapper.get();
    if (sharedCache == null) {
      return;
    }
    // Update partition cache
    try {
      // Wait if background cache update is happening
      partitionCacheLock.readLock().lock();
      isPartitionCacheDirty.set(true);
      for (int i = 0; i < partValsList.size(); i++) {
        List<String> partVals = partValsList.get(i);
        Partition newPart = newParts.get(i);
        sharedCache.alterPartitionInCache(dbName, tblName, partVals, newPart);
      }
    } finally {
      partitionCacheLock.readLock().unlock();
    }
    // Update partition column stats cache
    try {
      // Wait if background cache update is happening
      partitionColStatsCacheLock.readLock().lock();
      isPartitionColStatsCacheDirty.set(true);
      for (int i = 0; i < partValsList.size(); i++) {
        List<String> partVals = partValsList.get(i);
        Partition newPart = newParts.get(i);
        sharedCache.alterPartitionInColStatsCache(dbName, tblName, partVals, newPart);
      }
    } finally {
      partitionColStatsCacheLock.readLock().unlock();
    }
    // Remove aggregate partition col stats for this table
    try {
      // Wait if background cache update is happening
      partitionAggrColStatsCacheLock.readLock().lock();
      isPartitionAggrColStatsCacheDirty.set(true);
      sharedCache.removeAggrPartitionColStatsFromCache(dbName, tblName);
    } finally {
      partitionAggrColStatsCacheLock.readLock().unlock();
    }
  }

  @Override
  public boolean dropTable(String dbName, String tblName) throws MetaException,
      NoSuchObjectException, InvalidObjectException, InvalidInputException {
    boolean succ = rawStore.dropTable(dbName, tblName);
    if (succ) {
      dbName = StringUtils.normalizeIdentifier(dbName);
      tblName = StringUtils.normalizeIdentifier(tblName);
      if (!shouldCacheTable(dbName, tblName)) {
        return succ;
      }
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      // Remove table
      try {
        // Wait if background table cache update is happening
        tableCacheLock.readLock().lock();
        isTableCacheDirty.set(true);
        sharedCache.removeTableFromCache(dbName, tblName);
      } finally {
        tableCacheLock.readLock().unlock();
      }
      // Remove table col stats
      try {
        // Wait if background table col stats cache update is happening
        tableColStatsCacheLock.readLock().lock();
        isTableColStatsCacheDirty.set(true);
        sharedCache.removeTableColStatsFromCache(dbName, tblName);
      } finally {
        tableColStatsCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public boolean deletePartitionColumnStatistics(String dbName, String tblName, String partName,
      List<String> partVals, String colName)
      throws NoSuchObjectException, MetaException, InvalidObjectException, InvalidInputException {
    boolean succ =
        rawStore.deletePartitionColumnStatistics(dbName, tblName, partName, partVals, colName);
    if (succ) {
      dbName = StringUtils.normalizeIdentifier(dbName);
      tblName = StringUtils.normalizeIdentifier(tblName);
      if (!shouldCacheTable(dbName, tblName)) {
        return succ;
      }
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      try {
        // Wait if background cache update is happening
        partitionColStatsCacheLock.readLock().lock();
        isPartitionColStatsCacheDirty.set(true);
        sharedCache.removePartitionColStatsFromCache(dbName, tblName, partVals, colName);
      } finally {
        partitionColStatsCacheLock.readLock().unlock();
      }
      // Remove aggregate partition col stats for this table
      try {
        // Wait if background cache update is happening
        partitionAggrColStatsCacheLock.readLock().lock();
        isPartitionAggrColStatsCacheDirty.set(true);
        sharedCache.removeAggrPartitionColStatsFromCache(dbName, tblName);
      } finally {
        partitionAggrColStatsCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public boolean deleteTableColumnStatistics(String dbName, String tblName, String colName)
      throws NoSuchObjectException, MetaException, InvalidObjectException, InvalidInputException {
    boolean succ = rawStore.deleteTableColumnStatistics(dbName, tblName, colName);
    if (succ) {
      dbName = StringUtils.normalizeIdentifier(dbName);
      tblName = StringUtils.normalizeIdentifier(tblName);
      if (!shouldCacheTable(dbName, tblName)) {
        return succ;
      }
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      try {
        // Wait if background cache update is happening
        tableColStatsCacheLock.readLock().lock();
        isTableColStatsCacheDirty.set(true);
        sharedCache.removeTableColStatsFromCache(dbName, tblName, colName);
      } finally {
        tableColStatsCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public boolean dropPartition(String dbName, String tblName, List<String> part_vals)
      throws MetaException, NoSuchObjectException, InvalidObjectException, InvalidInputException {
    boolean succ = rawStore.dropPartition(dbName, tblName, part_vals);
    if (succ) {
      dbName = StringUtils.normalizeIdentifier(dbName);
      tblName = StringUtils.normalizeIdentifier(tblName);
      if (!shouldCacheTable(dbName, tblName)) {
        return succ;
      }
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      // Remove partition
      try {
        // Wait if background cache update is happening
        partitionCacheLock.readLock().lock();
        isPartitionCacheDirty.set(true);
        sharedCache.removePartitionFromCache(dbName, tblName, part_vals);
      } finally {
        partitionCacheLock.readLock().unlock();
      }
      // Remove partition col stats
      try {
        // Wait if background cache update is happening
        partitionColStatsCacheLock.readLock().lock();
        isPartitionColStatsCacheDirty.set(true);
        sharedCache.removePartitionColStatsFromCache(dbName, tblName, part_vals);
      } finally {
        partitionColStatsCacheLock.readLock().unlock();
      }
      // Remove aggregate partition col stats for this table
      try {
        // Wait if background cache update is happening
        partitionAggrColStatsCacheLock.readLock().lock();
        isPartitionAggrColStatsCacheDirty.set(true);
        sharedCache.removeAggrPartitionColStatsFromCache(dbName, tblName);
      } finally {
        partitionAggrColStatsCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public boolean updatePartitionColumnStatistics(ColumnStatistics colStats, List<String> partVals)
      throws NoSuchObjectException, MetaException, InvalidObjectException, InvalidInputException {
    boolean succ = rawStore.updatePartitionColumnStatistics(colStats, partVals);
    if (succ) {
      String dbName = StringUtils.normalizeIdentifier(colStats.getStatsDesc().getDbName());
      String tblName = StringUtils.normalizeIdentifier(colStats.getStatsDesc().getTableName());
      if (!shouldCacheTable(dbName, tblName)) {
        return succ;
      }
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      List<ColumnStatisticsObj> statsObjs = colStats.getStatsObj();
      Partition part = getPartition(dbName, tblName, partVals);
      List<String> colNames = new ArrayList<>();
      for (ColumnStatisticsObj statsObj : statsObjs) {
        colNames.add(statsObj.getColName());
      }
      StatsSetupConst.setColumnStatsState(part.getParameters(), colNames);
      // Update partition
      try {
        // Wait if background cache update is happening
        partitionCacheLock.readLock().lock();
        isPartitionCacheDirty.set(true);
        sharedCache.alterPartitionInCache(dbName, tblName, partVals, part);
      } finally {
        partitionCacheLock.readLock().unlock();
      }
      // Update partition column stats
      try {
        // Wait if background cache update is happening
        partitionColStatsCacheLock.readLock().lock();
        isPartitionColStatsCacheDirty.set(true);
        sharedCache.updatePartitionColStatsInCache(dbName, tblName, partVals,
            colStats.getStatsObj());
      } finally {
        partitionColStatsCacheLock.readLock().unlock();
      }
      // Remove aggregate partition col stats for this table
      try {
        // Wait if background cache update is happening
        partitionAggrColStatsCacheLock.readLock().lock();
        isPartitionAggrColStatsCacheDirty.set(true);
        sharedCache.removeAggrPartitionColStatsFromCache(dbName, tblName);
      } finally {
        partitionAggrColStatsCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public void createDatabase(Database db) throws InvalidObjectException, MetaException {
    rawStore.createDatabase(db);
    SharedCache sharedCache = sharedCacheWrapper.get();
    if (sharedCache == null) {
      return;
    }
    try {
      // Wait if background cache update is happening
      databaseCacheLock.readLock().lock();
      isDatabaseCacheDirty.set(true);
      sharedCache.addDatabaseToCache(StringUtils.normalizeIdentifier(db.getName()),
          db.deepCopy());
    } finally {
      databaseCacheLock.readLock().unlock();
    }
  }

  @Override
  public boolean addPartition(Partition part) throws InvalidObjectException, MetaException {
    boolean succ = rawStore.addPartition(part);
    if (succ) {
      String dbName = StringUtils.normalizeIdentifier(part.getDbName());
      String tblName = StringUtils.normalizeIdentifier(part.getTableName());
      if (!shouldCacheTable(dbName, tblName)) {
        return succ;
      }
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      try {
        // Wait if background cache update is happening
        partitionCacheLock.readLock().lock();
        isPartitionCacheDirty.set(true);
        sharedCache.addPartitionToCache(dbName, tblName, part);
      } finally {
        partitionCacheLock.readLock().unlock();
      }
      // Remove aggregate partition col stats for this table
      try {
        // Wait if background cache update is happening
        partitionAggrColStatsCacheLock.readLock().lock();
        isPartitionAggrColStatsCacheDirty.set(true);
        sharedCache.removeAggrPartitionColStatsFromCache(dbName, tblName);
      } finally {
        partitionAggrColStatsCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public boolean dropDatabase(String dbname) throws NoSuchObjectException, MetaException {
    boolean succ = rawStore.dropDatabase(dbname);
    if (succ) {
      SharedCache sharedCache = sharedCacheWrapper.get();
      if (sharedCache == null) {
        return succ;
      }
      try {
        // Wait if background cache update is happening
        databaseCacheLock.readLock().lock();
        isDatabaseCacheDirty.set(true);
        sharedCache.removeDatabaseFromCache(StringUtils.normalizeIdentifier(dbname));
      } finally {
        databaseCacheLock.readLock().unlock();
      }
    }
    return succ;
  }

  @Override
  public void dropPartitions(String dbName, String tblName, List<String> partNames)
      throws MetaException, NoSuchObjectException {
    rawStore.dropPartitions(dbName, tblName, partNames);
    dbName = StringUtils.normalizeIdentifier(dbName);
    tblName = StringUtils.normalizeIdentifier(tblName);
    if (!shouldCacheTable(dbName, tblName)) {
      return;
    }
    SharedCache sharedCache = sharedCacheWrapper.get();
    if (sharedCache == null) {
      return;
    }
    // Remove partitions
    try {
      // Wait if background cache update is happening
      partitionCacheLock.readLock().lock();
      isPartitionCacheDirty.set(true);
      for (String partName : partNames) {
        List<String> vals = partNameToVals(partName);
        sharedCache.removePartitionFromCache(dbName, tblName, vals);
      }
    } finally {
      partitionCacheLock.readLock().unlock();
    }
    // Remove partition col stats
    try {
      // Wait if background cache update is happening
      partitionColStatsCacheLock.readLock().lock();
      isPartitionColStatsCacheDirty.set(true);
      for (String partName : partNames) {
        List<String> part_vals = partNameToVals(partName);
        sharedCache.removePartitionColStatsFromCache(dbName, tblName, part_vals);
      }
    } finally {
      partitionColStatsCacheLock.readLock().unlock();
    }
    // Remove aggregate partition col stats for this table
    try {
      // Wait if background cache update is happening
      partitionAggrColStatsCacheLock.readLock().lock();
      isPartitionAggrColStatsCacheDirty.set(true);
      sharedCache.removeAggrPartitionColStatsFromCache(dbName, tblName);
    } finally {
      partitionAggrColStatsCacheLock.readLock().unlock();
    }
  }

}