public class DefaultXPathEvaluator {
    @SuppressWarnings("unchecked")
    private <T> List<T> evaluateMultiValues(final Class<T> componentType, final Class<?> callerClass) {
        validateEvaluationType(componentType);
        try {
            Document document = documentProvider.resolve(componentType, callerClass);
            XPathExpression expression = projector.config().createXPath(document).compile(duplexExpression.getExpressionAsStringWithoutFormatPatterns());
            InvocationContext invocationContext = new InvocationContext(null, null, expression, duplexExpression, null, componentType, projector);
            return (List<T>) evaluateAsList(expression, document, null, invocationContext);
        } catch (XPathExpressionException e) {
            throw new XBPathException(e,duplexExpression.getExpressionAsStringWithoutFormatPatterns());
        } catch (IOException e) {
            throw new XBIOException(e);
        }
    }

    @Override
    public <T> XBAutoMap<T> asMapOf(final Class<T> componentType) {
        try {
            final Class<?> callerClass = ReflectionHelper.getDirectCallerClass();
            Document document = documentProvider.resolve(componentType, callerClass);
            final String resolvedXPath = duplexExpression.getExpressionAsStringWithoutFormatPatterns();
            final XPath xpath = projector.config().createXPath(document);
            XPathExpression expression = xpath.compile(resolvedXPath);
//            final Node baseNode = (Node) expression.evaluate(document, XPathConstants.NODE);
//            if (baseNode.getNodeType() != Node.ELEMENT_NODE) {
//                throw new XBException("XPath expression does not resolve to an element. Maps can only be created for elements.");
//            }
            InvocationContext invocationContext = new InvocationContext(resolvedXPath, xpath, expression, duplexExpression, null, componentType, projector);
            return new AutoMap<T>(document, invocationContext, componentType);
        } catch (IOException e) {
            throw new XBIOException(e);
        } catch (XPathExpressionException e) {
            throw new XBPathException(e, duplexExpression.getExpressionAsStringWithoutFormatPatterns());
        }
    }

    @SuppressWarnings("unchecked")
    private <T> T evaluateSingeValue(final Class<T> returnType, final Class<?> callerClass) {
        try {
            final Document document = documentProvider.resolve(returnType, callerClass);

            final XPathExpression expression = projector.config().createXPath(document).compile(duplexExpression.getExpressionAsStringWithoutFormatPatterns());

            if (projector.config().getTypeConverter().isConvertable(returnType)) {
                String data;
                if (duplexExpression.getExpressionType().isMustEvalAsString()) {
                    data = (String) expression.evaluate(document, XPathConstants.STRING);
                } else {
                    Node dataNode = (Node) expression.evaluate(document, XPathConstants.NODE);
                    data = dataNode == null ? null : dataNode.getTextContent();
                }
                if ((data == null) && (projector.getFlags().contains(Flags.ABSENT_IS_EMPTY))) {
                    data = "";
                }

                final Object result = projector.config().getTypeConverter().convertTo(returnType, data, duplexExpression.getExpressionFormatPattern());
                return (T) result;
            }

            if (Node.class.isAssignableFrom(returnType)) {
                final Object result = expression.evaluate(document, XPathConstants.NODE);
                return (T) result;
            }

            if (returnType.isInterface()) {
                final Node node = (Node) expression.evaluate(document, XPathConstants.NODE);
                if (node == null) {
                    return null;
                }
                return projector.projectDOMNode(node, returnType);
            }
        } catch (XPathExpressionException e) {
            throw new XBPathException(e,duplexExpression.getExpressionAsStringWithoutFormatPatterns());
        } catch (IOException e) {
            throw new XBIOException(e);
        }
        throw new IllegalPathStateException();
    }

}