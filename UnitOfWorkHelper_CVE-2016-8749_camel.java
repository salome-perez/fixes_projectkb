public class UnitOfWorkHelper {
    public static void afterRouteSynchronizations(Route route, Exchange exchange, List<Synchronization> synchronizations, Logger log) {
        if (synchronizations != null && !synchronizations.isEmpty()) {
            // work on a copy of the list to avoid any modification which may cause ConcurrentModificationException
            List<Synchronization> copy = new ArrayList<Synchronization>(synchronizations);

            // reverse so we invoke it FILO style instead of FIFO
            Collections.reverse(copy);
            // and honor if any was ordered by sorting it accordingly
            copy.sort(new OrderedComparator());

            // invoke synchronization callbacks
            for (Synchronization synchronization : copy) {
                if (synchronization instanceof SynchronizationRouteAware) {
                    try {
                        log.trace("Invoking synchronization.onAfterRoute: {} with {}", synchronization, exchange);
                        ((SynchronizationRouteAware) synchronization).onAfterRoute(route, exchange);
                    } catch (Throwable e) {
                        // must catch exceptions to ensure all synchronizations have a chance to run
                        log.warn("Exception occurred during onAfterRoute. This exception will be ignored.", e);
                    }
                }
            }
        }
    }

    public static void doneSynchronizations(Exchange exchange, List<Synchronization> synchronizations, Logger log) {
        boolean failed = exchange.isFailed();

        if (synchronizations != null && !synchronizations.isEmpty()) {
            // work on a copy of the list to avoid any modification which may cause ConcurrentModificationException
            List<Synchronization> copy = new ArrayList<Synchronization>(synchronizations);

            // reverse so we invoke it FILO style instead of FIFO
            Collections.reverse(copy);
            // and honor if any was ordered by sorting it accordingly
            copy.sort(new OrderedComparator());

            // invoke synchronization callbacks
            for (Synchronization synchronization : copy) {
                try {
                    if (failed) {
                        log.trace("Invoking synchronization.onFailure: {} with {}", synchronization, exchange);
                        synchronization.onFailure(exchange);
                    } else {
                        log.trace("Invoking synchronization.onComplete: {} with {}", synchronization, exchange);
                        synchronization.onComplete(exchange);
                    }
                } catch (Throwable e) {
                    // must catch exceptions to ensure all synchronizations have a chance to run
                    log.warn("Exception occurred during onCompletion. This exception will be ignored.", e);
                }
            }
        }
    }

    public static void beforeRouteSynchronizations(Route route, Exchange exchange, List<Synchronization> synchronizations, Logger log) {
        if (synchronizations != null && !synchronizations.isEmpty()) {
            // work on a copy of the list to avoid any modification which may cause ConcurrentModificationException
            List<Synchronization> copy = new ArrayList<Synchronization>(synchronizations);

            // reverse so we invoke it FILO style instead of FIFO
            Collections.reverse(copy);
            // and honor if any was ordered by sorting it accordingly
            copy.sort(new OrderedComparator());

            // invoke synchronization callbacks
            for (Synchronization synchronization : copy) {
                if (synchronization instanceof SynchronizationRouteAware) {
                    try {
                        log.trace("Invoking synchronization.onBeforeRoute: {} with {}", synchronization, exchange);
                        ((SynchronizationRouteAware) synchronization).onBeforeRoute(route, exchange);
                    } catch (Throwable e) {
                        // must catch exceptions to ensure all synchronizations have a chance to run
                        log.warn("Exception occurred during onBeforeRoute. This exception will be ignored.", e);
                    }
                }
            }
        }
    }

}