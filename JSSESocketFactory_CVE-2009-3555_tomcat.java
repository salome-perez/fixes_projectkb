public class JSSESocketFactory {
    protected TrustManager[] getTrustManagers(String keystoreType,
            String keystoreProvider, String algorithm)
        throws Exception {
        String crlf = (String) attributes.get(
                AbstractEndpoint.SSL_ATTR_CRL_FILE);
        
        TrustManager[] tms = null;
        
        KeyStore trustStore = getTrustStore(keystoreType, keystoreProvider);
        if (trustStore != null) {
            if (crlf == null) {
                TrustManagerFactory tmf =
                    TrustManagerFactory.getInstance(algorithm);
                tmf.init(trustStore);
                tms = tmf.getTrustManagers();
            } else {
                TrustManagerFactory tmf =
                    TrustManagerFactory.getInstance(algorithm);
                CertPathParameters params =
                    getParameters(algorithm, crlf, trustStore);
                ManagerFactoryParameters mfp =
                    new CertPathTrustManagerParameters(params);
                tmf.init(mfp);
                tms = tmf.getTrustManagers();
            }
        }
        
        return tms;
    }

    @Override
    public Socket acceptSocket(ServerSocket socket)
        throws IOException
    {
        SSLSocket asock = null;
        try {
             asock = (SSLSocket)socket.accept();
        } catch (SSLException e){
          throw new SocketException("SSL handshake error" + e.toString());
        }
        return asock;
    }

    protected KeyStore getTrustStore(String keystoreType,
            String keystoreProvider) throws IOException {
        KeyStore trustStore = null;

        String truststoreFile = (String)attributes.get(
                AbstractEndpoint.SSL_ATTR_TRUSTSTORE_FILE);
        if(truststoreFile == null) {
            truststoreFile = System.getProperty("javax.net.ssl.trustStore");
        }
        if(log.isDebugEnabled()) {
            log.debug("Truststore = " + truststoreFile);
        }

        String truststorePassword = (String)attributes.get(
                AbstractEndpoint.SSL_ATTR_TRUSTSTORE_PASS);
        if( truststorePassword == null) {
            truststorePassword =
                System.getProperty("javax.net.ssl.trustStorePassword");
        }
        if( truststorePassword == null ) {
            truststorePassword = getKeystorePassword();
        }
        if(log.isDebugEnabled()) {
            log.debug("TrustPass = " + truststorePassword);
        }

        String truststoreType = (String)attributes.get(
                AbstractEndpoint.SSL_ATTR_TRUSTSTORE_TYPE);
        if( truststoreType == null) {
            truststoreType = System.getProperty("javax.net.ssl.trustStoreType");
        }
        if(truststoreType == null) {
            truststoreType = keystoreType;
        }
        if(log.isDebugEnabled()) {
            log.debug("trustType = " + truststoreType);
        }

        String truststoreProvider =
            (String)attributes.get(
                    AbstractEndpoint.SSL_ATTR_TRUSTSTORE_PROVIDER);
        if( truststoreProvider == null) {
            truststoreProvider =
                System.getProperty("javax.net.ssl.trustStoreProvider");
        }
        if (truststoreProvider == null) {
            truststoreProvider = keystoreProvider;
        }
        if(log.isDebugEnabled()) {
            log.debug("trustProvider = " + truststoreProvider);
        }

        if (truststoreFile != null && truststorePassword != null){
            trustStore = getStore(truststoreType, truststoreProvider,
                    truststoreFile, truststorePassword);
        }

        return trustStore;
    }

    @Override
    public void handshake(Socket sock) throws IOException {
        // We do getSession instead of startHandshake() so we can call this multiple times
    	SSLSession session = ((SSLSocket)sock).getSession();
        if (session.getCipherSuite().equals("SSL_NULL_WITH_NULL_NULL"))
        	throw new IOException("SSL handshake failed. Ciper suite in SSL Session is SSL_NULL_WITH_NULL_NULL");

        if (!allowUnsafeLegacyRenegotiation) {
            // Prevent futher handshakes by removing all cipher suites
            ((SSLSocket) sock).setEnabledCipherSuites(new String[0]);
        }
    }

    protected CertPathParameters getParameters(String algorithm, 
                                                String crlf, 
                                                KeyStore trustStore)
        throws Exception {
        CertPathParameters params = null;
        if("PKIX".equalsIgnoreCase(algorithm)) {
            PKIXBuilderParameters xparams =
                new PKIXBuilderParameters(trustStore, new X509CertSelector());
            Collection<? extends CRL> crls = getCRLs(crlf);
            CertStoreParameters csp = new CollectionCertStoreParameters(crls);
            CertStore store = CertStore.getInstance("Collection", csp);
            xparams.addCertStore(store);
            xparams.setRevocationEnabled(true);
            String trustLength = (String)attributes.get(
                    AbstractEndpoint.SSL_ATTR_TRUST_MAX_CERT_LENGTH);
            if(trustLength != null) {
                try {
                    xparams.setMaxPathLength(Integer.parseInt(trustLength));
                } catch(Exception ex) {
                    log.warn("Bad maxCertLength: "+trustLength);
                }
            }

            params = xparams;
        } else {
            throw new CRLException("CRLs not supported for type: "+algorithm);
        }
        return params;
    }

    protected KeyStore getKeystore(String type, String provider, String pass)
            throws IOException {

        String keystoreFile = (String)attributes.get(
                AbstractEndpoint.SSL_ATTR_KEYSTORE_FILE);
        if (keystoreFile == null)
            keystoreFile = defaultKeystoreFile;

        return getStore(type, provider, keystoreFile, pass);
    }

    protected KeyManager[] getKeyManagers(String keystoreType,
                                          String keystoreProvider,
                                          String algorithm,
                                          String keyAlias)
                throws Exception {

        KeyManager[] kms = null;

        String keystorePass = getKeystorePassword();

        KeyStore ks = getKeystore(keystoreType, keystoreProvider, keystorePass);
        if (keyAlias != null && !ks.isKeyEntry(keyAlias)) {
            throw new IOException(
                    sm.getString("jsse.alias_no_key_entry", keyAlias));
        }

        KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);
        kmf.init(ks, keystorePass.toCharArray());

        kms = kmf.getKeyManagers();
        if (keyAlias != null) {
            String alias = keyAlias;
            if (JSSESocketFactory.defaultKeystoreType.equals(keystoreType)) {
                alias = alias.toLowerCase();
            }
            for(int i=0; i<kms.length; i++) {
                kms[i] = new JSSEKeyManager((X509KeyManager)kms[i], alias);
            }
        }

        return kms;
    }

    protected void configureClientAuth(SSLServerSocket socket){
        if (wantClientAuth){
            socket.setWantClientAuth(wantClientAuth);
        } else {
            socket.setNeedClientAuth(requireClientAuth);
        }
    }

    protected String getKeystorePassword() {
        String keyPass = (String)attributes.get(
                AbstractEndpoint.SSL_ATTR_KEY_PASS);
        if (keyPass == null) {
            keyPass = defaultKeyPass;
        }
        String keystorePass = (String)attributes.get(
                AbstractEndpoint.SSL_ATTR_KEYSTORE_PASS);
        if (keystorePass == null) {
            keystorePass = keyPass;
        }
        return keystorePass;
    }

    protected String[] getEnabledCiphers(String requestedCiphers,
                                         String[] supportedCiphers) {

        String[] result = null;

        if (requestedCiphers != null) {
            Vector<String> vec = null;
            String cipher = requestedCiphers;
            int index = requestedCiphers.indexOf(',');
            if (index != -1) {
                int fromIndex = 0;
                while (index != -1) {
                    cipher =
                        requestedCiphers.substring(fromIndex, index).trim();
                    if (cipher.length() > 0) {
                        for (int i=0; supportedCiphers != null
                                     && i<supportedCiphers.length; i++) {
                            if (supportedCiphers[i].equals(cipher)) {
                                if (vec == null) {
                                    vec = new Vector<String>();
                                }
                                vec.addElement(cipher);
                                break;
                            }
                        }
                    }
                    fromIndex = index+1;
                    index = requestedCiphers.indexOf(',', fromIndex);
                } // while
                cipher = requestedCiphers.substring(fromIndex);
            }

            if (cipher != null) {
                cipher = cipher.trim();
                if (cipher.length() > 0) {
                    for (int i=0; supportedCiphers != null
                                 && i<supportedCiphers.length; i++) {
                        if (supportedCiphers[i].equals(cipher)) {
                            if (vec == null) {
                                vec = new Vector<String>();
                            }
                            vec.addElement(cipher);
                            break;
                        }
                    }
                }
            }           

            if (vec != null) {
                result = new String[vec.size()];
                vec.copyInto(result);
            }
        } else {
            result = sslProxy.getDefaultCipherSuites();
        }

        return result;
    }

    void init() throws IOException {
        try {

            String clientAuthStr = (String) attributes.get(
                    AbstractEndpoint.SSL_ATTR_CLIENT_AUTH);
            if("true".equalsIgnoreCase(clientAuthStr) ||
               "yes".equalsIgnoreCase(clientAuthStr)) {
                requireClientAuth = true;
            } else if("want".equalsIgnoreCase(clientAuthStr)) {
                wantClientAuth = true;
            }

            // SSL protocol variant (e.g., TLS, SSL v3, etc.)
            String protocol = (String) attributes.get(
                    AbstractEndpoint.SSL_ATTR_SSL_PROTOCOL);
            if (protocol == null) {
                protocol = defaultProtocol;
            }

            // Certificate encoding algorithm (e.g., SunX509)
            String algorithm = (String) attributes.get(
                    AbstractEndpoint.SSL_ATTR_ALGORITHM);
            if (algorithm == null) {
                algorithm = KeyManagerFactory.getDefaultAlgorithm();
            }

            String keystoreType = (String) attributes.get(
                    AbstractEndpoint.SSL_ATTR_KEYSTORE_TYPE);
            if (keystoreType == null) {
                keystoreType = defaultKeystoreType;
            }

            String keystoreProvider =
                (String) attributes.get(
                        AbstractEndpoint.SSL_ATTR_KEYSTORE_PROVIDER);

            String trustAlgorithm =
                (String)attributes.get(
                        AbstractEndpoint.SSL_ATTR_TRUSTSTORE_ALGORITHM);
            if( trustAlgorithm == null ) {
                trustAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            }

            // Create and init SSLContext
            SSLContext context = SSLContext.getInstance(protocol); 
            context.init(getKeyManagers(keystoreType, keystoreProvider,
                    algorithm,
                    (String) attributes.get(AbstractEndpoint.SSL_ATTR_KEY_ALIAS)),
                    getTrustManagers(keystoreType, keystoreProvider,
                            trustAlgorithm),
                    new SecureRandom());

            // Configure SSL session cache
            int sessionCacheSize;
            if (attributes.get(
                    AbstractEndpoint.SSL_ATTR_SESSION_CACHE_SIZE) != null) {
                sessionCacheSize = Integer.parseInt(
                        (String)attributes.get(
                                AbstractEndpoint.SSL_ATTR_SESSION_CACHE_SIZE));
            } else {
                sessionCacheSize = defaultSessionCacheSize;
            }
            int sessionCacheTimeout;
            if (attributes.get(
                    AbstractEndpoint.SSL_ATTR_SESSION_TIMEOUT) != null) {
                sessionCacheTimeout = Integer.parseInt(
                        (String)attributes.get(
                                AbstractEndpoint.SSL_ATTR_SESSION_TIMEOUT));
            } else {
                sessionCacheTimeout = defaultSessionTimeout;
            }
            SSLSessionContext sessionContext =
                context.getServerSessionContext();
            if (sessionContext != null) {
                sessionContext.setSessionCacheSize(sessionCacheSize);
                sessionContext.setSessionTimeout(sessionCacheTimeout);
            }

            // create proxy
            sslProxy = context.getServerSocketFactory();

            // Determine which cipher suites to enable
            String requestedCiphers = (String)attributes.get(
                    AbstractEndpoint.SSL_ATTR_CIPHERS);
            enabledCiphers = getEnabledCiphers(requestedCiphers,
                    sslProxy.getSupportedCipherSuites());

            allowUnsafeLegacyRenegotiation =
                "true".equals(attributes.get(
                        AbstractEndpoint.SSL_ATTR_ALLOW_UNSAFE_RENEG));
            
            // Check the SSL config is OK
            checkConfig();

        } catch(Exception e) {
            if( e instanceof IOException )
                throw (IOException)e;
            throw new IOException(e.getMessage());
        }
    }

}