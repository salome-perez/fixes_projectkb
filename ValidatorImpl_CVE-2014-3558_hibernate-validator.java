public class ValidatorImpl {
	private <V> ValueContext<?, V> collectMetaConstraintsForPath(Class<?> clazz, Object value, Iterator<Path.Node> propertyIter, PathImpl propertyPath, List<MetaConstraint<?>> metaConstraintsList) {
		// cast is ok, since we are dealing with engine internal classes
		NodeImpl elem = (NodeImpl) propertyIter.next();
		Object newValue = value;

		BeanMetaData<?> metaData = beanMetaDataManager.getBeanMetaData( clazz );
		PropertyMetaData property = metaData.getMetaDataFor( elem.getName() );

		// use precomputed method list as ReflectionHelper#containsMember is slow
		if ( property == null ) {
			throw log.getInvalidPropertyPathException( elem.getName(), metaData.getBeanClass().getName() );
		}
		else if ( !propertyIter.hasNext() ) {
			metaConstraintsList.addAll( property.getConstraints() );
		}
		else {
			if ( property.isCascading() ) {
				Type type = property.getType();
				newValue = newValue == null ? null : getValue( newValue, property );
				if ( elem.isIterable() ) {
					if ( newValue != null && elem.getIndex() != null ) {
						newValue = ReflectionHelper.getIndexedValue( newValue, elem.getIndex() );
					}
					else if ( newValue != null && elem.getKey() != null ) {
						newValue = ReflectionHelper.getMappedValue( newValue, elem.getKey() );
					}
					else if ( newValue != null ) {
						throw log.getPropertyPathMustProvideIndexOrMapKeyException();
					}
					type = ReflectionHelper.getIndexedType( type );
				}

				Class<?> castedValueClass = newValue == null ? (Class<?>) type : newValue.getClass();
				return collectMetaConstraintsForPath(
						castedValueClass,
						newValue,
						propertyIter,
						propertyPath,
						metaConstraintsList
				);
			}
		}

		if ( newValue == null ) {
			return ValueContext.getLocalExecutionContext( clazz, null, propertyPath );
		}
		return ValueContext.getLocalExecutionContext( value, null, propertyPath );
	}

	private <T> int validateReturnValueForGroup(ValidationContext<T> validationContext, T bean, Object value, Group group) {
		int numberOfViolationsBefore = validationContext.getFailingConstraints().size();

		BeanMetaData<T> beanMetaData = beanMetaDataManager.getBeanMetaData( validationContext.getRootBeanClass() );
		ExecutableMetaData executableMetaData = beanMetaData.getMetaDataFor( validationContext.getExecutable() );

		if ( executableMetaData == null ) {
			// nothing to validate
			return 0;
		}

		// TODO GM: define behavior with respect to redefined default sequences. Should only the
		// sequence from the validated bean be honored or also default sequence definitions up in
		// the inheritance tree?
		// For now a redefined default sequence will only be considered if specified at the bean
		// hosting the validated itself, but no other default sequence from parent types

		List<Class<?>> groupList;
		if ( group.isDefaultGroup() ) {
			groupList = beanMetaData.getDefaultGroupSequence( bean );
		}
		else {
			groupList = Arrays.<Class<?>>asList( group.getDefiningClass() );
		}

		//the only case where we can have multiple groups here is a redefined default group sequence
		for ( Class<?> oneGroup : groupList ) {

			int numberOfViolationsOfCurrentGroup = 0;

			// validate constraints at return value itself
			ValueContext<?, Object> valueContext = getExecutableValueContext(
					executableMetaData.getKind() == ElementKind.CONSTRUCTOR ? value : bean,
					executableMetaData,
					oneGroup
			);

			valueContext.setCurrentValidatedValue( value );
			valueContext.appendNode( executableMetaData.getReturnValueMetaData() );
			setValidatedValueHandlerToValueContextIfPresent(
					valueContext,
					executableMetaData.getReturnValueMetaData()
			);

			numberOfViolationsOfCurrentGroup +=
					validateConstraintsForGroup(
							validationContext, valueContext, executableMetaData
					);
			if ( shouldFailFast( validationContext ) ) {
				return validationContext.getFailingConstraints().size() - numberOfViolationsBefore;
			}

			//stop processing after first group with errors occurred
			if ( numberOfViolationsOfCurrentGroup > 0 ) {
				break;
			}
		}

		return validationContext.getFailingConstraints().size() - numberOfViolationsBefore;
	}

	private <T> void setValidatedValueHandlerToValueContextIfPresent(ValueContext<?, T> valueContext, ConstraintMetaData metaData) {
		if ( metaData.requiresUnwrapping() ) {
			@SuppressWarnings("unchecked") //we know the handler matches the value type
					ValidatedValueUnwrapper<? super T> handler = (ValidatedValueUnwrapper<T>) getValidatedValueHandler(
					metaData.getType()
			);

			if ( handler == null ) {
				throw log.getNoUnwrapperFoundForTypeException( metaData.getType().toString() );
			}

			valueContext.setValidatedValueHandler( handler );
		}
	}

	private <T> int validateParametersForGroup(ValidationContext<T> validationContext, Object[] parameterValues, Group group) {
		int numberOfViolationsBefore = validationContext.getFailingConstraints().size();

		BeanMetaData<T> beanMetaData = beanMetaDataManager.getBeanMetaData( validationContext.getRootBeanClass() );
		ExecutableMetaData executableMetaData = beanMetaData.getMetaDataFor( validationContext.getExecutable() );

		if ( parameterValues.length != executableMetaData.getParameterTypes().length ) {
			throw log.getInvalidParameterCountForExecutableException(
					ExecutableElement.getExecutableAsString(
							executableMetaData.getType().toString() + "#" + executableMetaData.getName(),
							executableMetaData.getParameterTypes()
					), parameterValues.length, executableMetaData.getParameterTypes().length
			);
		}

		// TODO GM: define behavior with respect to redefined default sequences. Should only the
		// sequence from the validated bean be honored or also default sequence definitions up in
		// the inheritance tree?
		// For now a redefined default sequence will only be considered if specified at the bean
		// hosting the validated itself, but no other default sequence from parent types
		List<Class<?>> groupList;
		if ( group.isDefaultGroup() ) {
			groupList = beanMetaData.getDefaultGroupSequence( validationContext.getRootBean() );
		}
		else {
			groupList = Arrays.<Class<?>>asList( group.getDefiningClass() );
		}

		//the only case where we can have multiple groups here is a redefined default group sequence
		for ( Class<?> currentValidatedGroup : groupList ) {
			int numberOfViolationsOfCurrentGroup = 0;

			ValueContext<T, Object> valueContext = getExecutableValueContext(
					validationContext.getRootBean(), executableMetaData, currentValidatedGroup
			);
			valueContext.appendCrossParameterNode();
			valueContext.setCurrentValidatedValue( parameterValues );

			// 1. validate cross-parameter constraints
			numberOfViolationsOfCurrentGroup += validateConstraintsForGroup(
					validationContext, valueContext, executableMetaData.getCrossParameterConstraints()
			);
			if ( shouldFailFast( validationContext ) ) {
				return validationContext.getFailingConstraints().size() - numberOfViolationsBefore;
			}

			valueContext = getExecutableValueContext(
					validationContext.getRootBean(), executableMetaData, currentValidatedGroup
			);
			valueContext.setCurrentValidatedValue( parameterValues );

			// 2. validate parameter constraints
			for ( int i = 0; i < parameterValues.length; i++ ) {
				PathImpl originalPath = valueContext.getPropertyPath();

				ParameterMetaData parameterMetaData = executableMetaData.getParameterMetaData( i );
				Object value = parameterValues[i];

				if ( value != null ) {
					Class<?> valueType = value.getClass();
					if ( parameterMetaData.getType() instanceof Class && ( (Class<?>) parameterMetaData.getType() ).isPrimitive() ) {
						valueType = ReflectionHelper.unBoxedType( valueType );
					}
					if ( !TypeHelper.isAssignable( TypeHelper.getErasedType( parameterMetaData.getType() ), valueType ) ) {
						throw log.getParameterTypesDoNotMatchException(
								valueType.getName(),
								parameterMetaData.getType().toString(),
								i,
								validationContext.getExecutable().getMember()
						);
					}
				}

				valueContext.appendNode( parameterMetaData );
				setValidatedValueHandlerToValueContextIfPresent( valueContext, parameterMetaData );
				valueContext.setCurrentValidatedValue( value );

				numberOfViolationsOfCurrentGroup += validateConstraintsForGroup(
						validationContext, valueContext, parameterMetaData
				);
				if ( shouldFailFast( validationContext ) ) {
					return validationContext.getFailingConstraints().size() - numberOfViolationsBefore;
				}

				valueContext.setPropertyPath( originalPath );
			}

			//stop processing after first group with errors occurred
			if ( numberOfViolationsOfCurrentGroup > 0 ) {
				break;
			}
		}

		return validationContext.getFailingConstraints().size() - numberOfViolationsBefore;
	}

	private boolean validateConstraint(ValidationContext<?> validationContext,
									   ValueContext<?, Object> valueContext,
									   boolean propertyPathComplete,
									   MetaConstraint<?> metaConstraint) {

		boolean validationSuccessful = true;

		if ( metaConstraint.getElementType() != ElementType.TYPE ) {
			PropertyMetaData propertyMetaData = beanMetaDataManager.getBeanMetaData( valueContext.getCurrentBeanType() ).getMetaDataFor(
					ReflectionHelper.getPropertyName( metaConstraint.getLocation().getMember() )
			);

			if ( !propertyPathComplete ) {
				valueContext.appendNode( propertyMetaData );
			}
			setValidatedValueHandlerToValueContextIfPresent( valueContext, propertyMetaData );
		}
		else {
			valueContext.appendBeanNode();
		}

		if ( isValidationRequired( validationContext, valueContext, metaConstraint ) ) {
			if ( valueContext.getCurrentBean() != null ) {
				Object valueToValidate = getValue( metaConstraint.getLocation().getMember(), valueContext.getCurrentBean() );
				valueContext.setCurrentValidatedValue( valueToValidate );
			}
			validationSuccessful = metaConstraint.validateConstraint( validationContext, valueContext );
		}

		return validationSuccessful;
	}

	private void validateCascadedConstraints(ValidationContext<?> validationContext, ValueContext<?, Object> valueContext) {
		Validatable validatable = valueContext.getCurrentValidatable();
		PathImpl originalPath = valueContext.getPropertyPath();
		Class<?> originalGroup = valueContext.getCurrentGroup();

		for ( Cascadable cascadable : validatable.getCascadables() ) {
			valueContext.appendNode( cascadable );
			Class<?> group = cascadable.convertGroup( originalGroup );
			valueContext.setCurrentGroup( group );

			ElementType elementType = cascadable.getElementType();
			if ( isCascadeRequired(
					validationContext,
					valueContext.getCurrentBean(),
					valueContext.getPropertyPath(),
					elementType
			) ) {

				Object value = getValue( valueContext.getCurrentBean(), cascadable );

				// Value can be wrapped (e.g. Optional<Address>). Try to unwrap it
				ConstraintMetaData metaData = (ConstraintMetaData) cascadable;
				if ( metaData.requiresUnwrapping() ) {
					setValidatedValueHandlerToValueContextIfPresent( valueContext, metaData );
					valueContext.setCurrentValidatedValue( value );
					value = valueContext.getCurrentValidatedValue();
				}

				if ( value != null ) {

					// expand the group only if was created by group conversion;
					// otherwise we're looping through the right validation order
					// already and need only to pass the current element
					ValidationOrder validationOrder = validationOrderGenerator.getValidationOrder(
							group,
							group != originalGroup
					);

					// HV-902: First, validate the value itself
					Iterator<?> valueIter = Collections.singletonList( value ).iterator();
					validateCascadedConstraint(
							validationContext,
							valueIter,
							false,
							valueContext,
							validationOrder
					);
					if ( shouldFailFast( validationContext ) ) {
						return;
					}

					// Second, validate elements contained in the value if it is Iterable, Map, or an Array
					Type type = value.getClass();
					Iterator<?> elementsIter = createIteratorForCascadedValue( type, value, valueContext );
					boolean isIndexable = isIndexable( type );

					validateCascadedConstraint(
							validationContext,
							elementsIter,
							isIndexable,
							valueContext,
							validationOrder
					);
					if ( shouldFailFast( validationContext ) ) {
						return;
					}
				}
			}

			// reset the path
			valueContext.setPropertyPath( originalPath );
			valueContext.setCurrentGroup( originalGroup );
		}
	}

}