public class CGIServlet {
    private boolean setStatus(HttpServletResponse response, int status) throws IOException {
        if (status >= HttpServletResponse.SC_BAD_REQUEST) {
            response.sendError(status);
            return true;
        } else {
            response.setStatus(status);
            return false;
        }
    }

    private int getSCFromCGIStatusHeader(String value) {
        if (value.length() < 3) {
            // Not a valid status value
            log.warn(sm.getString("cgiServlet.runInvalidStatus", value));
            return HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
        }

        String status = value.substring(0, 3);

        int statusCode;
        try {
            statusCode = Integer.parseInt(status);
        } catch (NumberFormatException nfe) {
            // Not a valid status code
            log.warn(sm.getString("cgiServlet.runInvalidStatus", status));
            return HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
        }

        return statusCode;
    }

    private void sendToLog(BufferedReader rdr) {
        String line = null;
        int lineCount = 0 ;
        try {
            while ((line = rdr.readLine()) != null) {
                log.warn(sm.getString("cgiServlet.runStdErr", line));
                lineCount++ ;
            }
        } catch (IOException e) {
            log.warn(sm.getString("cgiServlet.runStdErrFail"), e);
        } finally {
            try {
                rdr.close();
            } catch (IOException e) {
                log.warn(sm.getString("cgiServlet.runStdErrFail"), e);
            }
        }
        if (lineCount > 0) {
            log.warn(sm.getString("cgiServlet.runStdErrCount", Integer.valueOf(lineCount)));
        }
    }

    protected void setupFromRequest(HttpServletRequest req)
            throws UnsupportedEncodingException {

        boolean isIncluded = false;

        // Look to see if this request is an include
        if (req.getAttribute(
                RequestDispatcher.INCLUDE_REQUEST_URI) != null) {
            isIncluded = true;
        }
        if (isIncluded) {
            this.contextPath = (String) req.getAttribute(
                    RequestDispatcher.INCLUDE_CONTEXT_PATH);
            this.servletPath = (String) req.getAttribute(
                    RequestDispatcher.INCLUDE_SERVLET_PATH);
            this.pathInfo = (String) req.getAttribute(
                    RequestDispatcher.INCLUDE_PATH_INFO);
        } else {
            this.contextPath = req.getContextPath();
            this.servletPath = req.getServletPath();
            this.pathInfo = req.getPathInfo();
        }
        // If getPathInfo() returns null, must be using extension mapping
        // In this case, pathInfo should be same as servletPath
        if (this.pathInfo == null) {
            this.pathInfo = this.servletPath;
        }

        // If the request method is GET, POST or HEAD and the query string
        // does not contain an unencoded "=" this is an indexed query.
        // The parsed query string becomes the command line parameters
        // for the cgi command.
        if (req.getMethod().equals("GET")
            || req.getMethod().equals("POST")
            || req.getMethod().equals("HEAD")) {
            String qs;
            if (isIncluded) {
                qs = (String) req.getAttribute(
                        RequestDispatcher.INCLUDE_QUERY_STRING);
            } else {
                qs = req.getQueryString();
            }
            if (qs != null && qs.indexOf('=') == -1) {
                StringTokenizer qsTokens = new StringTokenizer(qs, "+");
                while ( qsTokens.hasMoreTokens() ) {
                    cmdLineParameters.add(URLDecoder.decode(qsTokens.nextToken(),
                                            parameterEncoding));
                }
            }
        }
    }

    private void printServletEnvironment(HttpServletRequest req) throws IOException {

        // Document the properties from ServletRequest
        log.trace("ServletRequest Properties");
        Enumeration<String> attrs = req.getAttributeNames();
        while (attrs.hasMoreElements()) {
            String attr = attrs.nextElement();
            log.trace("Request Attribute: " + attr + ": [ " + req.getAttribute(attr) +"]");
        }
        log.trace("Character Encoding: [" + req.getCharacterEncoding() + "]");
        log.trace("Content Length: [" + req.getContentLengthLong() + "]");
        log.trace("Content Type: [" + req.getContentType() + "]");
        Enumeration<Locale> locales = req.getLocales();
        while (locales.hasMoreElements()) {
            Locale locale = locales.nextElement();
            log.trace("Locale: [" +locale + "]");
        }
        Enumeration<String> params = req.getParameterNames();
        while (params.hasMoreElements()) {
            String param = params.nextElement();
            for (String value : req.getParameterValues(param)) {
                log.trace("Request Parameter: " + param + ":  [" + value + "]");
            }
        }
        log.trace("Protocol: [" + req.getProtocol() + "]");
        log.trace("Remote Address: [" + req.getRemoteAddr() + "]");
        log.trace("Remote Host: [" + req.getRemoteHost() + "]");
        log.trace("Scheme: [" + req.getScheme() + "]");
        log.trace("Secure: [" + req.isSecure() + "]");
        log.trace("Server Name: [" + req.getServerName() + "]");
        log.trace("Server Port: [" + req.getServerPort() + "]");

        // Document the properties from HttpServletRequest
        log.trace("HttpServletRequest Properties");
        log.trace("Auth Type: [" + req.getAuthType() + "]");
        log.trace("Context Path: [" + req.getContextPath() + "]");
        Cookie cookies[] = req.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                log.trace("Cookie: " + cookie.getName() + ": [" + cookie.getValue() + "]");
            }
        }
        Enumeration<String> headers = req.getHeaderNames();
        while (headers.hasMoreElements()) {
            String header = headers.nextElement();
            log.trace("HTTP Header: " + header + ": [" + req.getHeader(header) + "]");
        }
        log.trace("Method: [" + req.getMethod() + "]");
        log.trace("Path Info: [" + req.getPathInfo() + "]");
        log.trace("Path Translated: [" + req.getPathTranslated() + "]");
        log.trace("Query String: [" + req.getQueryString() + "]");
        log.trace("Remote User: [" + req.getRemoteUser() + "]");
        log.trace("Requested Session ID: [" + req.getRequestedSessionId() + "]");
        log.trace("Requested Session ID From Cookie: [" +
                req.isRequestedSessionIdFromCookie() + "]");
        log.trace("Requested Session ID From URL: [" + req.isRequestedSessionIdFromURL() + "]");
        log.trace("Requested Session ID Valid: [" + req.isRequestedSessionIdValid() + "]");
        log.trace("Request URI: [" + req.getRequestURI() + "]");
        log.trace("Servlet Path: [" + req.getServletPath() + "]");
        log.trace("User Principal: [" + req.getUserPrincipal() + "]");

        // Process the current session (if there is one)
        HttpSession session = req.getSession(false);
        if (session != null) {

            // Document the session properties
            log.trace("HttpSession Properties");
            log.trace("ID: [" + session.getId() + "]");
            log.trace("Creation Time: [" + new Date(session.getCreationTime()) + "]");
            log.trace("Last Accessed Time: [" + new Date(session.getLastAccessedTime()) + "]");
            log.trace("Max Inactive Interval: [" + session.getMaxInactiveInterval() + "]");

            // Document the session attributes
            attrs = session.getAttributeNames();
            while (attrs.hasMoreElements()) {
                String attr = attrs.nextElement();
                log.trace("Session Attribute: " + attr + ": [" + session.getAttribute(attr) + "]");
            }
        }

        // Document the servlet configuration properties
        log.trace("ServletConfig Properties");
        log.trace("Servlet Name: [" + getServletConfig().getServletName() + "]");

        // Document the servlet configuration initialization parameters
        params = getServletConfig().getInitParameterNames();
        while (params.hasMoreElements()) {
            String param = params.nextElement();
            String value = getServletConfig().getInitParameter(param);
            log.trace("Servlet Init Param: " + param + ": [" + value + "]");
        }

        // Document the servlet context properties
        log.trace("ServletContext Properties");
        log.trace("Major Version: [" + getServletContext().getMajorVersion() + "]");
        log.trace("Minor Version: [" + getServletContext().getMinorVersion() + "]");
        log.trace("Real Path for '/': [" + getServletContext().getRealPath("/") + "]");
        log.trace("Server Info: [" + getServletContext().getServerInfo() + "]");

        // Document the servlet context initialization parameters
        log.trace("ServletContext Initialization Parameters");
        params = getServletContext().getInitParameterNames();
        while (params.hasMoreElements()) {
            String param = params.nextElement();
            String value = getServletContext().getInitParameter(param);
            log.trace("Servlet Context Init Param: " + param + ": [" + value + "]");
        }

        // Document the servlet context attributes
        log.trace("ServletContext Attributes");
        attrs = getServletContext().getAttributeNames();
        while (attrs.hasMoreElements()) {
            String attr = attrs.nextElement();
            log.trace("Servlet Context Attribute: " + attr +
                    ": [" + getServletContext().getAttribute(attr) + "]");
        }
    }

    protected CGIEnvironment(HttpServletRequest req,
                                ServletContext context) throws IOException {
        setupFromContext(context);
        setupFromRequest(req);

        this.valid = setCGIEnvironment(req);

        if (this.valid) {
            workingDirectory = new File(command.substring(0,
                    command.lastIndexOf(File.separator)));
        } else {
            workingDirectory = null;
        }
    }

    protected String[] findCGI(String pathInfo, String webAppRootDir,
                                String contextPath, String servletPath,
                                String cgiPathPrefix) {
        String path = null;
        String name = null;
        String scriptname = null;

        if (webAppRootDir != null &&
                webAppRootDir.lastIndexOf(File.separator) == (webAppRootDir.length() - 1)) {
            //strip the trailing "/" from the webAppRootDir
            webAppRootDir = webAppRootDir.substring(0, (webAppRootDir.length() - 1));
        }

        if (cgiPathPrefix != null) {
            webAppRootDir = webAppRootDir + File.separator + cgiPathPrefix;
        }

        if (log.isDebugEnabled()) {
            log.debug(sm.getString("cgiServlet.find.path", pathInfo, webAppRootDir));
        }

        File currentLocation = new File(webAppRootDir);
        StringTokenizer dirWalker = new StringTokenizer(pathInfo, "/");
        if (log.isDebugEnabled()) {
            log.debug(sm.getString("cgiServlet.find.location",
                    currentLocation.getAbsolutePath()));
        }
        StringBuilder cginameBuilder = new StringBuilder();
        while (!currentLocation.isFile() && dirWalker.hasMoreElements()) {
            String nextElement = (String) dirWalker.nextElement();
            currentLocation = new File(currentLocation, nextElement);
            cginameBuilder.append('/').append(nextElement);
            if (log.isDebugEnabled()) {
                log.debug(sm.getString("cgiServlet.find.location",
                        currentLocation.getAbsolutePath()));
            }
        }
        String cginame = cginameBuilder.toString();
        if (!currentLocation.isFile()) {
            return new String[] { null, null, null, null };
        }

        path = currentLocation.getAbsolutePath();
        name = currentLocation.getName();

        if (".".equals(contextPath)) {
            scriptname = servletPath;
        } else {
            scriptname = contextPath + servletPath;
        }
        if (!servletPath.equals(cginame)) {
            scriptname = scriptname + cginame;
        }

        if (log.isDebugEnabled()) {
            log.debug(sm.getString("cgiServlet.find.found", name, path, scriptname, cginame));
        }
        return new String[] { path, scriptname, cginame, name };
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res)
            throws ServletException, IOException {

        CGIEnvironment cgiEnv = new CGIEnvironment(req, getServletContext());

        if (cgiEnv.isValid()) {
            CGIRunner cgi = new CGIRunner(cgiEnv.getCommand(),
                                          cgiEnv.getEnvironment(),
                                          cgiEnv.getWorkingDirectory(),
                                          cgiEnv.getParameters());

            if ("POST".equals(req.getMethod())) {
                cgi.setInput(req.getInputStream());
            }
            cgi.setResponse(res);
            cgi.run();
        } else {
            res.sendError(404);
        }

        if (log.isTraceEnabled()) {
            String[] cgiEnvLines = cgiEnv.toString().split(System.lineSeparator());
            for (String cgiEnvLine : cgiEnvLines) {
                log.trace(cgiEnvLine);
            }

            printServletEnvironment(req);
        }
    }

    protected void expandCGIScript() {
        StringBuilder srcPath = new StringBuilder();
        StringBuilder destPath = new StringBuilder();
        InputStream is = null;

        // paths depend on mapping
        if (cgiPathPrefix == null ) {
            srcPath.append(pathInfo);
            is = context.getResourceAsStream(srcPath.toString());
            destPath.append(tmpDir);
            destPath.append(pathInfo);
        } else {
            // essentially same search algorithm as findCGI()
            srcPath.append(cgiPathPrefix);
            StringTokenizer pathWalker =
                    new StringTokenizer (pathInfo, "/");
            // start with first element
            while (pathWalker.hasMoreElements() && (is == null)) {
                srcPath.append("/");
                srcPath.append(pathWalker.nextElement());
                is = context.getResourceAsStream(srcPath.toString());
            }
            destPath.append(tmpDir);
            destPath.append("/");
            destPath.append(srcPath);
        }

        if (is == null) {
            // didn't find anything, give up now
            log.warn(sm.getString("cgiServlet.expandNotFound", srcPath));
            return;
        }

        File f = new File(destPath.toString());
        if (f.exists()) {
            try {
                is.close();
            } catch (IOException e) {
                log.warn(sm.getString("cgiServlet.expandCloseFail", srcPath), e);
            }
            // Don't need to expand if it already exists
            return;
        }

        // create directories
        File dir = f.getParentFile();
        if (!dir.mkdirs() && !dir.isDirectory()) {
            log.warn(sm.getString("cgiServlet.expandCreateDirFail", dir.getAbsolutePath()));
            return;
        }

        try {
            synchronized (expandFileLock) {
                // make sure file doesn't exist
                if (f.exists()) {
                    return;
                }

                // create file
                if (!f.createNewFile()) {
                    return;
                }

                try {
                    Files.copy(is, f.toPath());
                } finally {
                    is.close();
                }

                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("cgiServlet.expandOk", srcPath, destPath));
                }
            }
        } catch (IOException ioe) {
            log.warn(sm.getString("cgiServlet.expandFail", srcPath, destPath), ioe);
            // delete in case file is corrupted
            if (f.exists()) {
                if (!f.delete()) {
                    log.warn(sm.getString("cgiServlet.expandDeleteFail", f.getAbsolutePath()));
                }
            }
        }
    }

    protected void run() throws IOException {

        /*
         * REMIND:  this method feels too big; should it be re-written?
         */

        if (!isReady()) {
            throw new IOException(this.getClass().getName() + ": not ready to run.");
        }

        if (log.isDebugEnabled()) {
            log.debug("envp: [" + env + "], command: [" + command + "]");
        }

        if ((command.indexOf(File.separator + "." + File.separator) >= 0)
            || (command.indexOf(File.separator + "..") >= 0)
            || (command.indexOf(".." + File.separator) >= 0)) {
            throw new IOException(this.getClass().getName()
                                  + "Illegal Character in CGI command "
                                  + "path ('.' or '..') detected.  Not "
                                  + "running CGI [" + command + "].");
        }

        /* original content/structure of this section taken from
         * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4216884
         * with major modifications by Martin Dengler
         */
        Runtime rt = null;
        BufferedReader cgiHeaderReader = null;
        InputStream cgiOutput = null;
        BufferedReader commandsStdErr = null;
        Thread errReaderThread = null;
        BufferedOutputStream commandsStdIn = null;
        Process proc = null;
        int bufRead = -1;

        List<String> cmdAndArgs = new ArrayList<>();
        if (cgiExecutable.length() != 0) {
            cmdAndArgs.add(cgiExecutable);
        }
        if (cgiExecutableArgs != null) {
            cmdAndArgs.addAll(cgiExecutableArgs);
        }
        cmdAndArgs.add(command);
        cmdAndArgs.addAll(params);

        try {
            rt = Runtime.getRuntime();
            proc = rt.exec(
                    cmdAndArgs.toArray(new String[cmdAndArgs.size()]),
                    hashToStringArray(env), wd);

            String sContentLength = env.get("CONTENT_LENGTH");

            if(!"".equals(sContentLength)) {
                commandsStdIn = new BufferedOutputStream(proc.getOutputStream());
                IOTools.flow(stdin, commandsStdIn);
                commandsStdIn.flush();
                commandsStdIn.close();
            }

            /* we want to wait for the process to exit,  Process.waitFor()
             * is useless in our situation; see
             * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4223650
             */

            boolean isRunning = true;
            commandsStdErr = new BufferedReader
                (new InputStreamReader(proc.getErrorStream()));
            final BufferedReader stdErrRdr = commandsStdErr ;

            errReaderThread = new Thread() {
                @Override
                public void run () {
                    sendToLog(stdErrRdr);
                }
            };
            errReaderThread.start();

            InputStream cgiHeaderStream =
                new HTTPHeaderInputStream(proc.getInputStream());
            cgiHeaderReader =
                new BufferedReader(new InputStreamReader(cgiHeaderStream));

            // Need to be careful here. If sendError() is called the
            // response body should be provided by the standard error page
            // process. But, if the output of the CGI process isn't read
            // then that process can hang.
            boolean skipBody = false;

            while (isRunning) {
                try {
                    //set headers
                    String line = null;
                    while (((line = cgiHeaderReader.readLine()) != null) && !("".equals(line))) {
                        if (log.isTraceEnabled()) {
                            log.trace("addHeader(\"" + line + "\")");
                        }
                        if (line.startsWith("HTTP")) {
                            skipBody = setStatus(response, getSCFromHttpStatusLine(line));
                        } else if (line.indexOf(':') >= 0) {
                            String header =
                                line.substring(0, line.indexOf(':')).trim();
                            String value =
                                line.substring(line.indexOf(':') + 1).trim();
                            if (header.equalsIgnoreCase("status")) {
                                skipBody = setStatus(response, getSCFromCGIStatusHeader(value));
                            } else {
                                response.addHeader(header , value);
                            }
                        } else {
                            log.info(sm.getString("cgiServlet.runBadHeader", line));
                        }
                    }

                    //write output
                    byte[] bBuf = new byte[2048];

                    OutputStream out = response.getOutputStream();
                    cgiOutput = proc.getInputStream();

                    try {
                        while (!skipBody && (bufRead = cgiOutput.read(bBuf)) != -1) {
                            if (log.isTraceEnabled()) {
                                log.trace("output " + bufRead + " bytes of data");
                            }
                            out.write(bBuf, 0, bufRead);
                        }
                    } finally {
                        // Attempt to consume any leftover byte if something bad happens,
                        // such as a socket disconnect on the servlet side; otherwise, the
                        // external process could hang
                        if (bufRead != -1) {
                            while ((bufRead = cgiOutput.read(bBuf)) != -1) {
                                // NOOP - just read the data
                            }
                        }
                    }

                    proc.exitValue(); // Throws exception if alive

                    isRunning = false;

                } catch (IllegalThreadStateException e) {
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException ignored) {
                        // Ignore
                    }
                }
            } //replacement for Process.waitFor()

        } catch (IOException e){
            log.warn(sm.getString("cgiServlet.runFail"), e);
            throw e;
        } finally {
            // Close the header reader
            if (cgiHeaderReader != null) {
                try {
                    cgiHeaderReader.close();
                } catch (IOException ioe) {
                    log.warn(sm.getString("cgiServlet.runHeaderReaderFail"), ioe);
                }
            }
            // Close the output stream if used
            if (cgiOutput != null) {
                try {
                    cgiOutput.close();
                } catch (IOException ioe) {
                    log.warn(sm.getString("cgiServlet.runOutputStreamFail"), ioe);
                }
            }
            // Make sure the error stream reader has finished
            if (errReaderThread != null) {
                try {
                    errReaderThread.join(stderrTimeout);
                } catch (InterruptedException e) {
                    log.warn(sm.getString("cgiServlet.runReaderInterupt"));                    }
            }
            if (proc != null){
                proc.destroy();
                proc = null;
            }
        }
    }

    protected boolean setCGIEnvironment(HttpServletRequest req) throws IOException {

        /*
         * This method is slightly ugly; c'est la vie.
         * "You cannot stop [ugliness], you can only hope to contain [it]"
         * (apologies to Marv Albert regarding MJ)
         */

        Hashtable<String,String> envp = new Hashtable<>();

        // Add the shell environment variables (if any)
        envp.putAll(shellEnv);

        // Add the CGI environment variables
        String sPathInfoOrig = null;
        String sPathInfoCGI = null;
        String sPathTranslatedCGI = null;
        String sCGIFullPath = null;
        String sCGIScriptName = null;
        String sCGIFullName = null;
        String sCGIName = null;
        String[] sCGINames;


        sPathInfoOrig = this.pathInfo;
        sPathInfoOrig = sPathInfoOrig == null ? "" : sPathInfoOrig;

        if (webAppRootDir == null ) {
            // The app has not been deployed in exploded form
            webAppRootDir = tmpDir.toString();
            expandCGIScript();
        }

        sCGINames = findCGI(sPathInfoOrig,
                            webAppRootDir,
                            contextPath,
                            servletPath,
                            cgiPathPrefix);

        sCGIFullPath = sCGINames[0];
        sCGIScriptName = sCGINames[1];
        sCGIFullName = sCGINames[2];
        sCGIName = sCGINames[3];

        if (sCGIFullPath == null
            || sCGIScriptName == null
            || sCGIFullName == null
            || sCGIName == null) {
            return false;
        }

        envp.put("SERVER_SOFTWARE", "TOMCAT");

        envp.put("SERVER_NAME", nullsToBlanks(req.getServerName()));

        envp.put("GATEWAY_INTERFACE", "CGI/1.1");

        envp.put("SERVER_PROTOCOL", nullsToBlanks(req.getProtocol()));

        int port = req.getServerPort();
        Integer iPort =
            (port == 0 ? Integer.valueOf(-1) : Integer.valueOf(port));
        envp.put("SERVER_PORT", iPort.toString());

        envp.put("REQUEST_METHOD", nullsToBlanks(req.getMethod()));

        envp.put("REQUEST_URI", nullsToBlanks(req.getRequestURI()));


        /*-
         * PATH_INFO should be determined by using sCGIFullName:
         * 1) Let sCGIFullName not end in a "/" (see method findCGI)
         * 2) Let sCGIFullName equal the pathInfo fragment which
         *    corresponds to the actual cgi script.
         * 3) Thus, PATH_INFO = request.getPathInfo().substring(
         *                      sCGIFullName.length())
         *
         * (see method findCGI, where the real work is done)
         *
         */
        if (pathInfo == null
            || (pathInfo.substring(sCGIFullName.length()).length() <= 0)) {
            sPathInfoCGI = "";
        } else {
            sPathInfoCGI = pathInfo.substring(sCGIFullName.length());
        }
        envp.put("PATH_INFO", sPathInfoCGI);


        /*-
         * PATH_TRANSLATED must be determined after PATH_INFO (and the
         * implied real cgi-script) has been taken into account.
         *
         * The following example demonstrates:
         *
         * servlet info   = /servlet/cgigw/dir1/dir2/cgi1/trans1/trans2
         * cgifullpath    = /servlet/cgigw/dir1/dir2/cgi1
         * path_info      = /trans1/trans2
         * webAppRootDir  = servletContext.getRealPath("/")
         *
         * path_translated = servletContext.getRealPath("/trans1/trans2")
         *
         * That is, PATH_TRANSLATED = webAppRootDir + sPathInfoCGI
         * (unless sPathInfoCGI is null or blank, then the CGI
         * specification dictates that the PATH_TRANSLATED metavariable
         * SHOULD NOT be defined.
         *
         */
        if (!("".equals(sPathInfoCGI))) {
            sPathTranslatedCGI = context.getRealPath(sPathInfoCGI);
        }
        if (sPathTranslatedCGI == null || "".equals(sPathTranslatedCGI)) {
            //NOOP
        } else {
            envp.put("PATH_TRANSLATED", nullsToBlanks(sPathTranslatedCGI));
        }


        envp.put("SCRIPT_NAME", nullsToBlanks(sCGIScriptName));

        envp.put("QUERY_STRING", nullsToBlanks(req.getQueryString()));

        envp.put("REMOTE_HOST", nullsToBlanks(req.getRemoteHost()));

        envp.put("REMOTE_ADDR", nullsToBlanks(req.getRemoteAddr()));

        envp.put("AUTH_TYPE", nullsToBlanks(req.getAuthType()));

        envp.put("REMOTE_USER", nullsToBlanks(req.getRemoteUser()));

        envp.put("REMOTE_IDENT", ""); //not necessary for full compliance

        envp.put("CONTENT_TYPE", nullsToBlanks(req.getContentType()));


        /* Note CGI spec says CONTENT_LENGTH must be NULL ("") or undefined
         * if there is no content, so we cannot put 0 or -1 in as per the
         * Servlet API spec.
         */
        long contentLength = req.getContentLengthLong();
        String sContentLength = (contentLength <= 0 ? "" :
            Long.toString(contentLength));
        envp.put("CONTENT_LENGTH", sContentLength);


        Enumeration<String> headers = req.getHeaderNames();
        String header = null;
        while (headers.hasMoreElements()) {
            header = null;
            header = headers.nextElement().toUpperCase(Locale.ENGLISH);
            //REMIND: rewrite multiple headers as if received as single
            //REMIND: change character set
            //REMIND: I forgot what the previous REMIND means
            if (envHttpHeadersPattern.matcher(header).matches()) {
                envp.put("HTTP_" + header.replace('-', '_'), req.getHeader(header));
            }
        }

        File fCGIFullPath = new File(sCGIFullPath);
        command = fCGIFullPath.getCanonicalPath();

        envp.put("X_TOMCAT_SCRIPT_PATH", command);  //for kicks

        envp.put("SCRIPT_FILENAME", command);  //for PHP

        this.env = envp;

        return true;

    }

    @Override
    public String toString() {

        StringBuilder sb = new StringBuilder();

        sb.append("CGIEnvironment Info:");
        sb.append(System.lineSeparator());

        if (isValid()) {
            sb.append("Validity: [true]");
            sb.append(System.lineSeparator());

            sb.append("Environment values:");
            sb.append(System.lineSeparator());
            for (Entry<String,String> entry : env.entrySet()) {
                sb.append("  ");
                sb.append(entry.getKey());
                sb.append(": [");
                sb.append(blanksToString(entry.getValue(), "will be set to blank"));
                sb.append("]");
                sb.append(System.lineSeparator());
            }

            sb.append("Derived Command :[");
            sb.append(nullsToBlanks(command));
            sb.append("]");
            sb.append(System.lineSeparator());


            sb.append("Working Directory: [");
            if (workingDirectory != null) {
                sb.append(workingDirectory.toString());
            }
            sb.append("]");
            sb.append(System.lineSeparator());

            sb.append("Command Line Params:");
            sb.append(System.lineSeparator());
            for (String param : cmdLineParameters) {
                sb.append("  [");
                sb.append(param);
                sb.append("]");
                sb.append(System.lineSeparator());
            }
        } else {
            sb.append("Validity: [false]");
            sb.append(System.lineSeparator());
            sb.append("CGI script not found or not specified.");
            sb.append(System.lineSeparator());
            sb.append("Check the HttpServletRequest pathInfo property to see if it is what ");
            sb.append(System.lineSeparator());
            sb.append("you meant it to be. You must specify an existant and executable file ");
            sb.append(System.lineSeparator());
            sb.append("as part of the path-info.");
            sb.append(System.lineSeparator());
        }

        return sb.toString();
    }

    private int getSCFromHttpStatusLine(String line) {
        int statusStart = line.indexOf(' ') + 1;

        if (statusStart < 1 || line.length() < statusStart + 3) {
            // Not a valid HTTP Status-Line
            log.warn(sm.getString("cgiServlet.runInvalidStatus", line));
            return HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
        }

        String status = line.substring(statusStart, statusStart + 3);

        int statusCode;
        try {
            statusCode = Integer.parseInt(status);
        } catch (NumberFormatException nfe) {
            // Not a valid status code
            log.warn(sm.getString("cgiServlet.runInvalidStatus", status));
            return HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
        }

        return statusCode;
    }

    @Override
    public void init(ServletConfig config) throws ServletException {

        super.init(config);

        // Set our properties from the initialization parameters
        cgiPathPrefix = getServletConfig().getInitParameter("cgiPathPrefix");
        boolean passShellEnvironment =
            Boolean.parseBoolean(getServletConfig().getInitParameter("passShellEnvironment"));

        if (passShellEnvironment) {
            shellEnv.putAll(System.getenv());
        }

        if (getServletConfig().getInitParameter("executable") != null) {
            cgiExecutable = getServletConfig().getInitParameter("executable");
        }

        if (getServletConfig().getInitParameter("executable-arg-1") != null) {
            List<String> args = new ArrayList<>();
            for (int i = 1;; i++) {
                String arg = getServletConfig().getInitParameter(
                        "executable-arg-" + i);
                if (arg == null) {
                    break;
                }
                args.add(arg);
            }
            cgiExecutableArgs = args;
        }

        if (getServletConfig().getInitParameter("parameterEncoding") != null) {
            parameterEncoding = getServletConfig().getInitParameter("parameterEncoding");
        }

        if (getServletConfig().getInitParameter("stderrTimeout") != null) {
            stderrTimeout = Long.parseLong(getServletConfig().getInitParameter(
                    "stderrTimeout"));
        }

        if (getServletConfig().getInitParameter("envHttpHeaders") != null) {
            envHttpHeadersPattern =
                    Pattern.compile(getServletConfig().getInitParameter("envHttpHeaders"));
        }
    }
}