public class BCrypt {
	public static boolean checkpw(String plaintext, String hashed) {
		byte hashed_bytes[];
		byte try_bytes[];
		try {
			String try_pw = hashpw(plaintext, hashed);
			hashed_bytes = hashed.getBytes("UTF-8");
			try_bytes = try_pw.getBytes("UTF-8");
		} catch (UnsupportedEncodingException uee) {
			return false;
		}
		if (hashed_bytes.length != try_bytes.length)
			return false;
		byte ret = 0;
		for (int i = 0; i < try_bytes.length; i++)
			ret |= hashed_bytes[i] ^ try_bytes[i];
		return ret == 0;
	}

	public static String gensalt() {
		return gensalt(GENSALT_DEFAULT_LOG2_ROUNDS);
	}

	public static String hashpw(String password, String salt) {
		BCrypt B;
		String real_salt;
		byte passwordb[], saltb[], hashed[];
		char minor = (char)0;
		int rounds, off = 0;
		StringBuffer rs = new StringBuffer();

		if (salt.charAt(0) != '$' || salt.charAt(1) != '2')
			throw new IllegalArgumentException ("Invalid salt version");
		if (salt.charAt(2) == '$')
			off = 3;
		else {
			minor = salt.charAt(2);
			if (minor != 'a' || salt.charAt(3) != '$')
				throw new IllegalArgumentException ("Invalid salt revision");
			off = 4;
		}

		// Extract number of rounds
		if (salt.charAt(off + 2) > '$')
			throw new IllegalArgumentException ("Missing salt rounds");
		rounds = Integer.parseInt(salt.substring(off, off + 2));

		real_salt = salt.substring(off + 3, off + 25);
		try {
			passwordb = (password + (minor >= 'a' ? "\000" : "")).getBytes("UTF-8");
		} catch (UnsupportedEncodingException uee) {
			throw new AssertionError("UTF-8 is not supported");
		}

		saltb = decode_base64(real_salt, BCRYPT_SALT_LEN);

		B = new BCrypt();
		hashed = B.crypt_raw(passwordb, saltb, rounds,
		    (int[])bf_crypt_ciphertext.clone());

		rs.append("$2");
		if (minor >= 'a')
			rs.append(minor);
		rs.append("$");
		if (rounds < 10)
			rs.append("0");
		if (rounds > 30) {
			throw new IllegalArgumentException(
			    "rounds exceeds maximum (30)");
		}
		rs.append(Integer.toString(rounds));
		rs.append("$");
		rs.append(encode_base64(saltb, saltb.length));
		rs.append(encode_base64(hashed,
		    bf_crypt_ciphertext.length * 4 - 1));
		return rs.toString();
	}

	public byte[] crypt_raw(byte password[], byte salt[], int log_rounds,
	    int cdata[]) {
		int rounds, i, j;
		int clen = cdata.length;
		byte ret[];

		if (log_rounds < 4 || log_rounds > 30)
			throw new IllegalArgumentException ("Bad number of rounds");
		rounds = 1 << log_rounds;
		if (salt.length != BCRYPT_SALT_LEN)
			throw new IllegalArgumentException ("Bad salt length");

		init_key();
		ekskey(salt, password);
		for (i = 0; i != rounds; i++) {
			key(password);
			key(salt);
		}

		for (i = 0; i < 64; i++) {
			for (j = 0; j < (clen >> 1); j++)
				encipher(cdata, j << 1);
		}

		ret = new byte[clen * 4];
		for (i = 0, j = 0; i < clen; i++) {
			ret[j++] = (byte)((cdata[i] >> 24) & 0xff);
			ret[j++] = (byte)((cdata[i] >> 16) & 0xff);
			ret[j++] = (byte)((cdata[i] >> 8) & 0xff);
			ret[j++] = (byte)(cdata[i] & 0xff);
		}
		return ret;
	}

}