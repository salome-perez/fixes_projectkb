public class CipherText {
	public byte[] asPortableSerializedByteArray() throws EncryptionException {
        // Check if this CipherText object is "complete", i.e., all
        // mandatory has been collected.
	    if ( ! collectedAll() ) {
	        String msg = "Can't serialize this CipherText object yet as not " +
	                     "all mandatory information has been collected";
	        throw new EncryptionException("Can't serialize incomplete ciphertext info", msg);
	    }
	    
	    // If we are supposed to be using a (separate) MAC, also make sure
	    // that it has been computed/stored.
	    boolean requiresMAC = ESAPI.securityConfiguration().useMACforCipherText();
	    if (  requiresMAC && ! macComputed() ) {
	        String msg = "Programming error: MAC is required for this cipher mode (" +
	                     getCipherMode() + "), but MAC has not yet been " +
	                     "computed and stored. Call the method " +
	                     "computeAndStoreMAC(SecretKey) first before " +
	                     "attempting serialization.";
	        throw new EncryptionException("Can't serialize ciphertext info: Data integrity issue.",
	                                      msg);
	    }
	    
	    // OK, everything ready, so give it a shot.
	    return new CipherTextSerializer(this).asSerializedByteArray();
	}
	public boolean validateMAC(SecretKey authKey) {
	    boolean requiresMAC = ESAPI.securityConfiguration().useMACforCipherText();

	    if (  requiresMAC && macComputed() ) {  // Uses MAC and it was computed
	        // Calculate MAC from HMAC-SHA1(nonce, IV + plaintext) and
	        // compare to stored value (separate_mac_). If same, then return true,
	        // else return false.
	        byte[] mac = computeMAC(authKey);
	        assert mac.length == separate_mac_.length : "MACs are of differnt lengths. Should both be the same.";
	        return CryptoHelper.arrayCompare(mac, separate_mac_); // Safe compare!!!
	    } else if ( ! requiresMAC ) {           // Doesn't require a MAC
	        return true;
	    } else {
	    		// This *used* to be the case (for versions 2.0 and 2.0.1) where we tried to
	    		// accomodate the deprecated decrypt() method from ESAPI 1.4. Unfortunately,
	    		// that was an EPIC FAIL. (See Google Issue # 306 for details.)
	        logger.warning(Logger.SECURITY_FAILURE, "MAC may have been tampered with (e.g., length set to 0).");
	        return false;    // Deprecated decrypt() method removed, so now return false.
	    }
	}	    
}