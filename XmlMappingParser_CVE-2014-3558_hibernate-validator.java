public class XmlMappingParser {
	public final void parse(Set<InputStream> mappingStreams) {
		try {
			JAXBContext jc = JAXBContext.newInstance( ConstraintMappingsType.class );

			Set<String> alreadyProcessedConstraintDefinitions = newHashSet();
			for ( InputStream in : mappingStreams ) {
				String schemaVersion = xmlParserHelper.getSchemaVersion( "constraint mapping file", in );
				String schemaResourceName = getSchemaResourceName( schemaVersion );
				Schema schema = xmlParserHelper.getSchema( schemaResourceName );

				Unmarshaller unmarshaller = jc.createUnmarshaller();
				unmarshaller.setSchema( schema );

				ConstraintMappingsType mapping = getValidationConfig( in, unmarshaller );
				String defaultPackage = mapping.getDefaultPackage();

				parseConstraintDefinitions(
						mapping.getConstraintDefinition(),
						defaultPackage,
						alreadyProcessedConstraintDefinitions
				);

				for ( BeanType bean : mapping.getBean() ) {
					Class<?> beanClass = ClassLoadingHelper.loadClass( bean.getClazz(), defaultPackage );
					checkClassHasNotBeenProcessed( processedClasses, beanClass );

					// update annotation ignores
					annotationProcessingOptions.ignoreAnnotationConstraintForClass(
							beanClass,
							bean.getIgnoreAnnotations()
					);

					ConstrainedType constrainedType = ConstrainedTypeBuilder.buildConstrainedType(
							bean.getClassType(),
							beanClass,
							defaultPackage,
							constraintHelper,
							annotationProcessingOptions,
							defaultSequences
					);
					if ( constrainedType != null ) {
						addConstrainedElement( beanClass, constrainedType );
					}

					Set<ConstrainedField> constrainedFields = ConstrainedFieldBuilder.buildConstrainedFields(
							bean.getField(),
							beanClass,
							defaultPackage,
							constraintHelper,
							annotationProcessingOptions
					);
					addConstrainedElements( beanClass, constrainedFields );

					Set<ConstrainedExecutable> constrainedGetters = ConstrainedGetterBuilder.buildConstrainedGetters(
							bean.getGetter(),
							beanClass,
							defaultPackage,
							constraintHelper,
							annotationProcessingOptions
					);
					addConstrainedElements( beanClass, constrainedGetters );

					Set<ConstrainedExecutable> constrainedConstructors = ConstrainedExecutableBuilder.buildConstructorConstrainedExecutable(
							bean.getConstructor(),
							beanClass,
							defaultPackage,
							parameterNameProvider,
							constraintHelper,
							annotationProcessingOptions
					);
					addConstrainedElements( beanClass, constrainedConstructors );

					Set<ConstrainedExecutable> constrainedMethods = ConstrainedExecutableBuilder.buildMethodConstrainedExecutable(
							bean.getMethod(),
							beanClass,
							defaultPackage,
							parameterNameProvider,
							constraintHelper,
							annotationProcessingOptions
					);
					addConstrainedElements( beanClass, constrainedMethods );

					processedClasses.add( beanClass );
				}
			}
		}
		catch ( JAXBException e ) {
			throw log.getErrorParsingMappingFileException( e );
		}
	}

	@SuppressWarnings("unchecked")
	private void parseConstraintDefinitions(List<ConstraintDefinitionType> constraintDefinitionList,
											String defaultPackage,
											Set<String> alreadyProcessedConstraintDefinitions) {
		for ( ConstraintDefinitionType constraintDefinition : constraintDefinitionList ) {
			String annotationClassName = constraintDefinition.getAnnotation();
			if ( alreadyProcessedConstraintDefinitions.contains( annotationClassName ) ) {
				throw log.getOverridingConstraintDefinitionsInMultipleMappingFilesException( annotationClassName );
			}
			else {
				alreadyProcessedConstraintDefinitions.add( annotationClassName );
			}

			Class<?> clazz = ClassLoadingHelper.loadClass( annotationClassName, defaultPackage );
			if ( !clazz.isAnnotation() ) {
				throw log.getIsNotAnAnnotationException( annotationClassName );
			}
			Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) clazz;

			addValidatorDefinitions( annotationClass, constraintDefinition.getValidatedBy() );
		}
	}

	private <A extends Annotation> void addValidatorDefinitions(Class<A> annotationClass, ValidatedByType validatedByType) {
		List<Class<? extends ConstraintValidator<A, ?>>> constraintValidatorClasses = newArrayList();

		for ( String validatorClassName : validatedByType.getValue() ) {
			@SuppressWarnings("unchecked")
			Class<? extends ConstraintValidator<A, ?>> validatorClass = (Class<? extends ConstraintValidator<A, ?>>) run(
					LoadClass.action( validatorClassName, this.getClass() )
			);


			if ( !ConstraintValidator.class.isAssignableFrom( validatorClass ) ) {
				throw log.getIsNotAConstraintValidatorClassException( validatorClass );
			}

			constraintValidatorClasses.add( validatorClass );
		}
		constraintHelper.putValidatorClasses(
				annotationClass,
				constraintValidatorClasses,
				Boolean.TRUE.equals( validatedByType.getIncludeExistingValidators() )
		);
	}

}