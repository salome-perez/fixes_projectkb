public class GrizzlyAsyncHttpProvider {
    void initializeTransport(final AsyncHttpClientConfig clientConfig) {

        final FilterChainBuilder secure = FilterChainBuilder.stateless();
        secure.add(new TransportFilter());

        final int timeout = clientConfig.getRequestTimeoutInMs();
        if (timeout > 0) {
            int delay = 500;
            //noinspection ConstantConditions
            if (timeout < delay) {
                delay = timeout - 10;
                if (delay <= 0) {
                    delay = timeout;
                }
            }
            timeoutExecutor = IdleTimeoutFilter.createDefaultIdleDelayedExecutor(delay, TimeUnit.MILLISECONDS);
            timeoutExecutor.start();
            final IdleTimeoutFilter.TimeoutResolver timeoutResolver = new IdleTimeoutFilter.TimeoutResolver() {
                @Override
                public long getTimeout(FilterChainContext ctx) {
                    final HttpTxContext context = HttpTxContext.get(ctx);
                    if (context != null) {
                        if (context.isWSRequest()) {
                            return clientConfig.getWebSocketIdleTimeoutInMs();
                        }
                        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(clientConfig, context.getRequest());
                        if (requestTimeout > 0) {
                            return requestTimeout;
                        }
                    }
                    return IdleTimeoutFilter.FOREVER;
                }
            };
            final IdleTimeoutFilter timeoutFilter = new IdleTimeoutFilter(timeoutExecutor, timeoutResolver,
                    new IdleTimeoutFilter.TimeoutHandler() {
                        public void onTimeout(Connection connection) {
                            timeout(connection);
                        }
                    });
            secure.add(timeoutFilter);
            resolver = timeoutFilter.getResolver();
        }

        SSLContext context = clientConfig.getSSLContext();
        if (context == null) {
            try {
                context = SslUtils.getInstance().getSSLContext(clientConfig.isAcceptAnyCertificate());
            } catch (Exception e) {
                throw new IllegalStateException(e);
            }
        }
        final SSLEngineConfigurator configurator = new SSLEngineConfigurator(context, true, false, false);
        final SwitchingSSLFilter filter = new SwitchingSSLFilter(configurator);
        secure.add(filter);
        GrizzlyAsyncHttpProviderConfig providerConfig = (GrizzlyAsyncHttpProviderConfig) clientConfig.getAsyncHttpProviderConfig();

        boolean npnEnabled = NextProtoNegSupport.isEnabled();
        boolean spdyEnabled = clientConfig.isSpdyEnabled();

        if (spdyEnabled) {
            // if NPN isn't available, check to see if it has been explicitly
            // disabled.  If it has, we assume the user knows what they are doing
            // and we enable SPDY without NPN - this effectively disables standard
            // HTTP/1.1 support.
            if (!npnEnabled && providerConfig != null) {
                if ((Boolean) providerConfig.getProperty(Property.NPN_ENABLED)) {
                    // NPN hasn't been disabled, so it's most likely a configuration problem.
                    // Log a warning and disable spdy support.
                    LOGGER.warn("Next Protocol Negotiation support is not available.  SPDY support has been disabled.");
                    spdyEnabled = false;
                }
            }
        }

        final AsyncHttpClientEventFilter eventFilter;
        final EventHandler handler = new EventHandler(clientConfig);
        if (providerConfig != null) {
            eventFilter = new AsyncHttpClientEventFilter(handler, (Integer) providerConfig.getProperty(MAX_HTTP_PACKET_HEADER_SIZE));
        } else {
            eventFilter = new AsyncHttpClientEventFilter(handler);
        }
        handler.cleanup = eventFilter;
        ContentEncoding[] encodings = eventFilter.getContentEncodings();
        if (encodings.length > 0) {
            for (ContentEncoding encoding : encodings) {
                eventFilter.removeContentEncoding(encoding);
            }
        }
        if (clientConfig.isCompressionEnabled()) {
            eventFilter.addContentEncoding(new GZipContentEncoding(512, 512, new ClientEncodingFilter()));
        }
        secure.add(eventFilter);
        final AsyncHttpClientFilter clientFilter = new AsyncHttpClientFilter(this, clientConfig);
        secure.add(clientFilter);
        secure.add(new WebSocketClientFilter());

        clientTransport.getAsyncQueueIO().getWriter().setMaxPendingBytesPerConnection(AUTO_SIZE);
        if (providerConfig != null) {
            final TransportCustomizer customizer = (TransportCustomizer) providerConfig.getProperty(Property.TRANSPORT_CUSTOMIZER);
            if (customizer != null) {
                customizer.customize(clientTransport, secure);
            } else {
                doDefaultTransportConfig();
            }
        } else {
            doDefaultTransportConfig();
        }

        // FilterChain for the standard HTTP case has been configured, we now
        // copy it and modify for SPDY purposes.
        if (spdyEnabled) {
            FilterChainBuilder spdyFilterChain = createSpdyFilterChain(secure, npnEnabled);
            ProtocolNegotiator pn = new ProtocolNegotiator(spdyFilterChain.build());
            NextProtoNegSupport.getInstance().setClientSideNegotiator(clientTransport, pn);
        }

        // Install the HTTP filter chain.
        //clientTransport.setProcessor(fcb.build());
        FilterChainBuilder nonSecure = FilterChainBuilder.stateless();
        nonSecure.addAll(secure);
        int idx = nonSecure.indexOfType(SSLFilter.class);
        nonSecure.remove(idx);
        final ConnectionPool pool;
        if (providerConfig != null) {
            pool = (ConnectionPool) providerConfig.getProperty(CONNECTION_POOL);
        } else {
            pool = null;
        }
        connectionManager = new ConnectionManager(this, pool, secure, nonSecure, filter);

    }

}