public class Executor {
    private void finish2() {
        for (RuntimeException e1 : owner.getTerminatedBy()) {
            LOGGER.log(Level.FINE, String.format("%s termination trace", getName()), e1);
        }
        owner.removeExecutor(this);
        if (this instanceof OneOffExecutor) {
            owner.remove((OneOffExecutor) this);
        }
        executableEstimatedDuration = DEFAULT_ESTIMATED_DURATION;
        queue.scheduleMaintenance();
    }
    @Exported
    public int getProgress() {
        long d = executableEstimatedDuration;
        if (d <= 0) {
            return DEFAULT_ESTIMATED_DURATION;
        }

        int num = (int) (getElapsedTime() * 100 / d);
        if (num >= 100) {
            num = 99;
        }
        return num;
    }
    @Deprecated
    public static long getEstimatedDurationFor(Executable e) {
        return e == null ? DEFAULT_ESTIMATED_DURATION : e.getEstimatedDuration();
    }
    public long getEstimatedRemainingTimeMillis() {
        long d = executableEstimatedDuration;
        if (d < 0) {
            return DEFAULT_ESTIMATED_DURATION;
        }

        long eta = d - getElapsedTime();
        if (eta <= 0) {
            return DEFAULT_ESTIMATED_DURATION;
        }

        return eta;
    }
    public long getIdleStartMilliseconds() {
        if (isIdle())
            return Math.max(creationTime, owner.getConnectTime());
        else {
            return Math.max(startTime + Math.max(0, executableEstimatedDuration), System.currentTimeMillis() + 15000);
        }
    }
    public String getEstimatedRemainingTime() {
        long d = executableEstimatedDuration;
        if (d < 0) {
            return Messages.Executor_NotAvailable();
        }

        long eta = d - getElapsedTime();
        if (eta <= 0) {
            return Messages.Executor_NotAvailable();
        }

        return Util.getTimeSpanString(eta);
    }
    @Exported
    public boolean isLikelyStuck() {
        lock.readLock().lock();
        try {
            if (executable == null) {
                return false;
            }
        } finally {
            lock.readLock().unlock();
        }

        long elapsed = getElapsedTime();
        long d = executableEstimatedDuration;
        if (d >= 0) {
            // if it's taking 10 times longer than ETA, consider it stuck
            return d * 10 < elapsed;
        } else {
            // if no ETA is available, a build taking longer than a day is considered stuck
            return TimeUnit.MILLISECONDS.toHours(elapsed) > 24;
        }
    }
}