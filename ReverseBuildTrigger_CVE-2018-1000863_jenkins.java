public class ReverseBuildTrigger {
        private Map<Job,Collection<ReverseBuildTrigger>> calculateCache() {
            try (ACLContext _ = ACL.as(ACL.SYSTEM)) {
                final Map<Job, Collection<ReverseBuildTrigger>> result = new WeakHashMap<>();
                for (Job<?, ?> downstream : Jenkins.getInstance().allItems(Job.class)) {
                    ReverseBuildTrigger trigger =
                            ParameterizedJobMixIn.getTrigger(downstream, ReverseBuildTrigger.class);
                    if (trigger == null) {
                        continue;
                    }
                    List<Job> upstreams =
                            Items.fromNameList(downstream.getParent(), trigger.getUpstreamProjects(), Job.class);
                    LOGGER.log(Level.FINE, "from {0} see upstreams {1}", new Object[]{downstream, upstreams});
                    for (Job upstream : upstreams) {
                        if (upstream instanceof AbstractProject && downstream instanceof AbstractProject) {
                            continue; // handled specially
                        }
                        Collection<ReverseBuildTrigger> triggers = result.get(upstream);
                        if (triggers == null) {
                            triggers = new LinkedList<>();
                            result.put(upstream, triggers);
                        }
                        triggers.remove(trigger);
                        triggers.add(trigger);
                    }
                }
                return result;
            }
        }

    @Override public void buildDependencyGraph(final AbstractProject downstream, DependencyGraph graph) {
        for (AbstractProject upstream : Items.fromNameList(downstream.getParent(), getUpstreamProjects(), AbstractProject.class)) {
            graph.addDependency(new DependencyGraph.Dependency(upstream, downstream) {
                @Override public boolean shouldTriggerBuild(AbstractBuild upstreamBuild, TaskListener listener, List<Action> actions) {
                    return shouldTrigger(upstreamBuild, listener);
                }
            });
        }
    }

    public String getUpstreamProjects() {
        return Util.fixNull(upstreamProjects);
    }

        public void onLocationChanged(Item item, final String oldFullName, final String newFullName) {
            try (ACLContext _ = ACL.as(ACL.SYSTEM)) {
                for (Job<?, ?> p : Jenkins.getInstance().allItems(Job.class)) {
                    ReverseBuildTrigger t = ParameterizedJobMixIn.getTrigger(p, ReverseBuildTrigger.class);
                    if (t != null) {
                        String revised =
                                Items.computeRelativeNamesAfterRenaming(oldFullName, newFullName,
                                        t.getUpstreamProjects(), p.getParent());
                        if (!revised.equals(t.upstreamProjects)) {
                            t.upstreamProjects = revised;
                            try {
                                p.save();
                            } catch (IOException e) {
                                LOGGER.log(Level.WARNING,
                                        "Failed to persist project setting during rename from " + oldFullName + " to "
                                                + newFullName, e);
                            }
                        }
                    }
                }
            }
        }

}