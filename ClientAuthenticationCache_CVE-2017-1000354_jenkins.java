public class ClientAuthenticationCache {
    public Authentication get() {
        Jenkins h = Jenkins.getInstance();
        String val = props.getProperty(getPropertyKey());
        if (val == null) {
            LOGGER.finer("No stored CLI authentication");
            return Jenkins.ANONYMOUS;
        }
        Secret oldSecret = Secret.decrypt(val);
        if (oldSecret != null) {
            LOGGER.log(Level.FINE, "Ignoring insecure stored CLI authentication for {0}", oldSecret.getPlainText());
            return Jenkins.ANONYMOUS;
        }
        int idx = val.lastIndexOf(':');
        if (idx == -1) {
            LOGGER.log(Level.FINE, "Ignoring malformed stored CLI authentication: {0}", val);
            return Jenkins.ANONYMOUS;
        }
        String username = val.substring(0, idx);
        if (!MAC.checkMac(username, val.substring(idx + 1))) {
            LOGGER.log(Level.FINE, "Ignoring stored CLI authentication due to MAC mismatch: {0}", val);
            return Jenkins.ANONYMOUS;
        }
        try {
            UserDetails u = h.getSecurityRealm().loadUserByUsername(username);
            LOGGER.log(Level.FINER, "Loaded stored CLI authentication for {0}", username);
            return new UsernamePasswordAuthenticationToken(u.getUsername(), "", u.getAuthorities());
        } catch (AuthenticationException | DataAccessException x) {
            LOGGER.log(Level.FINE, "Stored CLI authentication did not correspond to a valid user: " + username, x);
            return Jenkins.ANONYMOUS;
        }
    }

    @VisibleForTesting
    void save() throws IOException, InterruptedException {
        OutputStream os = store.write();
        try {
            props.store(os,"Credential store");
        } finally {
            os.close();
        }
        // try to protect this file from other users, if we can.
        store.chmod(0600);
    }

    @VisibleForTesting
    String getPropertyKey() {
        String url = Jenkins.getInstance().getRootUrl();
        if (url!=null)  return url;
        return Secret.fromString("key").toString();
    }

    public void set(Authentication a) throws IOException, InterruptedException {
        Jenkins h = Jenkins.getInstance();

        // make sure that this security realm is capable of retrieving the authentication by name,
        // as it's not required.
        UserDetails u = h.getSecurityRealm().loadUserByUsername(a.getName());
        String username = u.getUsername();
        props.setProperty(getPropertyKey(), username + ":" + MAC.mac(username));

        save();
    }

}