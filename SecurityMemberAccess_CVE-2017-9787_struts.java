public class SecurityMemberAccess {
    @Override
    public boolean isAccessible(Map context, Object target, Member member, String propertyName) {
        if (checkEnumAccess(target, member)) {
            if (LOG.isTraceEnabled()) {
                LOG.trace("Allowing access to enum #0", target);
            }
            return true;
        }

        Class targetClass = target.getClass();
        Class memberClass = member.getDeclaringClass();

        if (Modifier.isStatic(member.getModifiers()) && allowStaticMethodAccess) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("Support for accessing static methods [target: #0, member: #1, property: #2] is deprecated!", target, member, propertyName);
            }
            if (!isClassExcluded(member.getDeclaringClass())) {
                targetClass = member.getDeclaringClass();
            }
        }

        if (isPackageExcluded(targetClass.getPackage(), memberClass.getPackage())) {
            if (LOG.isWarnEnabled()) {
                LOG.warn("Package of target [#0] or package of member [#1] are excluded!", target, member);
            }
            return false;
        }

        if (isClassExcluded(targetClass)) {
            if (LOG.isWarnEnabled()) {
                LOG.warn("Target class [#0] is excluded!", target);
            }
            return false;
        }

        if (isClassExcluded(memberClass)) {
            if (LOG.isWarnEnabled()) {
                LOG.warn("Declaring class of member type [#0] is excluded!", member);
            }
            return false;
        }

        if (disallowProxyMemberAccess && ProxyUtil.isProxyMember(member, target)) {
            LOG.warn("Access to proxy [#0] is blocked!", member);
            return false;
        }

        boolean allow = true;
        if (!checkStaticMethodAccess(member)) {
            if (LOG.isTraceEnabled()) {
                LOG.warn("Access to static [#0] is blocked!", member);
            }
            allow = false;
        }

        //failed static test
        if (!allow)
            return false;

        // Now check for standard scope rules
        return super.isAccessible(context, target, member, propertyName)
                && isAcceptableProperty(propertyName);
    }

}