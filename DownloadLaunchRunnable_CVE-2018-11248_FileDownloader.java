public class DownloadLaunchRunnable {
    private void trialConnect() throws IOException, RetryDirectly, IllegalAccessException,
            FileDownloadSecurityException {
        FileDownloadConnection trialConnection = null;
        try {
            final ConnectionProfile trialConnectionProfile;
            if (isNeedForceDiscardRange) {
                trialConnectionProfile = ConnectionProfile.ConnectionProfileBuild
                        .buildTrialConnectionProfileNoRange();
            } else {
                trialConnectionProfile = ConnectionProfile.ConnectionProfileBuild
                        .buildTrialConnectionProfile();
            }
            final ConnectTask trialConnectTask = new ConnectTask.Builder()
                    .setDownloadId(model.getId())
                    .setUrl(model.getUrl())
                    .setEtag(model.getETag())
                    .setHeader(userRequestHeader)
                    .setConnectionProfile(trialConnectionProfile)
                    .build();
            trialConnection = trialConnectTask.connect();
            handleTrialConnectResult(trialConnectTask.getRequestHeader(),
                    trialConnectTask, trialConnection);

        } finally {
            if (trialConnection != null) trialConnection.ending();
        }
    }

    @Override
    public void run() {
        try {
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

            // status checkout
            if (model.getStatus() != FileDownloadStatus.pending) {
                if (model.getStatus() == FileDownloadStatus.paused) {
                    if (FileDownloadLog.NEED_LOG) {
                        FileDownloadLog.d(this, "High concurrent cause, start runnable but "
                                + "already paused %d", model.getId());
                    }

                } else {
                    onError(new RuntimeException(
                            FileDownloadUtils.formatString("Task[%d] can't start the download"
                                            + " runnable, because its status is %d not %d",
                                    model.getId(), model.getStatus(), FileDownloadStatus.pending)));
                }
                return;
            }

            if (!paused) {
                statusCallback.onStartThread();
            }

            do {
                if (paused) {
                    if (FileDownloadLog.NEED_LOG) {
                        FileDownloadLog.d(this, "High concurrent cause, start runnable but "
                                + "already paused %d", model.getId());
                    }
                    return;
                }

                try {
                    // 1. check env state
                    checkupBeforeConnect();

                    // 2. trial connect
                    trialConnect();

                    // 3. reuse same task
                    checkupAfterGetFilename();

                    // 4. check local resume model
                    final List<ConnectionModel> connectionOnDBList = database
                            .findConnectionModel(model.getId());
                    inspectTaskModelResumeAvailableOnDB(connectionOnDBList);

                    if (paused) {
                        model.setStatus(FileDownloadStatus.paused);
                        return;
                    }

                    final long totalLength = model.getTotal();

                    // 5. pre-allocate if need.
                    handlePreAllocate(totalLength, model.getTempFilePath());

                    // 6. calculate block count
                    final int connectionCount = calcConnectionCount(totalLength);
                    if (connectionCount <= 0) {
                        throw new IllegalAccessException(FileDownloadUtils
                                .formatString("invalid connection count %d, the connection count"
                                        + " must be larger than 0", connectionCount));
                    }

                    if (totalLength == 0) {
                        return;
                    }

                    if (paused) {
                        model.setStatus(FileDownloadStatus.paused);
                        return;
                    }

                    // 7. start real connect and fetch to local filesystem
                    isSingleConnection = connectionCount == 1;
                    if (isSingleConnection) {
                        // single connection
                        realDownloadWithSingleConnection(totalLength);
                    } else {
                        // multiple connection
                        statusCallback.onMultiConnection();
                        if (isResumeAvailableOnDB) {
                            realDownloadWithMultiConnectionFromResume(connectionCount,
                                    connectionOnDBList);
                        } else {
                            realDownloadWithMultiConnectionFromBeginning(totalLength,
                                    connectionCount);
                        }
                    }

                } catch (IOException | IllegalAccessException
                        | InterruptedException | IllegalArgumentException
                        | FileDownloadSecurityException
                        | FileDownloadGiveUpRetryException e) {
                    if (isRetry(e)) {
                        onRetry(e);
                        continue;
                    } else {
                        onError(e);
                    }
                } catch (DiscardSafely discardSafely) {
                    return;
                } catch (RetryDirectly retryDirectly) {
                    model.setStatus(FileDownloadStatus.retry);
                    continue;
                }

                break;
            } while (true);
        } finally {
            statusCallback.discardAllMessage();

            if (paused) {
                statusCallback.onPausedDirectly();
            } else if (error) {
                statusCallback.onErrorDirectly(errorException);
            } else {
                try {
                    statusCallback.onCompletedDirectly();
                } catch (IOException e) {
                    statusCallback.onErrorDirectly(e);
                }
            }

            alive.set(false);
        }
    }

    private void handleTrialConnectResult(Map<String, List<String>> requestHeader,
                                          ConnectTask connectTask,
                                          FileDownloadConnection connection)
            throws IOException, RetryDirectly, IllegalArgumentException,
            FileDownloadSecurityException {
        final int id = model.getId();
        final int code = connection.getResponseCode();

        acceptPartial = FileDownloadUtils.isAcceptRange(code, connection);
        final boolean onlyFromBeginning = (code == HttpURLConnection.HTTP_OK
                || code == HttpURLConnection.HTTP_CREATED
                || code == FileDownloadConnection.NO_RESPONSE_CODE);

        final String oldEtag = model.getETag();
        String newEtag = FileDownloadUtils.findEtag(id, connection);

        // handle whether need retry because of etag is overdue
        boolean isPreconditionFailed = false;
        do {
            if (code == HttpURLConnection.HTTP_PRECON_FAILED) {
                isPreconditionFailed = true;
                break;
            }

            if (oldEtag != null && !oldEtag.equals(newEtag)) {
                // etag changed.
                if (onlyFromBeginning || acceptPartial) {
                    // 200 or 206
                    isPreconditionFailed = true;
                    break;
                }
            }

            if (code == HttpURLConnection.HTTP_CREATED && connectTask.isRangeNotFromBeginning()) {
                // The request has been fulfilled and has resulted in one or more new resources
                // being created. mark this case is precondition failed for
                // 1. checkout whether accept partial
                // 2. 201 means new resources so range must be from beginning otherwise it can't
                // match local range.
                isPreconditionFailed = true;
                break;
            }

            if (code == HTTP_REQUESTED_RANGE_NOT_SATISFIABLE) {
                if (model.getSoFar() > 0) {
                    // On the first connection range not satisfiable, there must something wrong,
                    // so have to retry.
                    isPreconditionFailed = true;
                    break;
                } else {
                    // range is right, but get 416
                    if (!isNeedForceDiscardRange) {
                        // if range is still added, but range is right with 416 response, so we
                        // discard range on header and try again
                        isNeedForceDiscardRange = true;
                        isPreconditionFailed = true;
                    }
                }
            }

        } while (false);


        if (isPreconditionFailed) {
            // the file on remote is changed
            if (isResumeAvailableOnDB) {
                FileDownloadLog.w(this, "there is precondition failed on this request[%d] "
                                + "with old etag[%s]、new etag[%s]、response code is %d",
                        id, oldEtag, newEtag, code);
            }

            database.removeConnections(model.getId());
            FileDownloadUtils.deleteTaskFiles(model.getTargetFilePath(), model.getTempFilePath());
            isResumeAvailableOnDB = false;

            if (oldEtag != null && oldEtag.equals(newEtag)) {
                FileDownloadLog.w(this, "the old etag[%s] is the same to the new etag[%s], "
                                + "but the response status code is %d not Partial(206), so wo have"
                                + " to start this task from very beginning for task[%d]!",
                        oldEtag, newEtag, code, id);
                newEtag = null;
            }

            model.setSoFar(0);
            model.setTotal(0);
            model.setETag(newEtag);
            model.resetConnectionCount();

            database.updateOldEtagOverdue(id, model.getETag(), model.getSoFar(), model.getTotal(),
                    model.getConnectionCount());

            // retry to check whether support partial or not.
            throw new RetryDirectly();
        }

        redirectedUrl = connectTask.getFinalRedirectedUrl();
        if (acceptPartial || onlyFromBeginning) {
            final long totalLength = FileDownloadUtils.findInstanceLengthForTrial(connection);

            // update model
            String fileName = null;
            if (model.isPathAsDirectory()) {
                // filename
                fileName = FileDownloadUtils.findFilename(connection, model.getUrl());
            }
            isChunked = (totalLength == TOTAL_VALUE_IN_CHUNKED_RESOURCE);

            // callback
            statusCallback.onConnected(isResumeAvailableOnDB && acceptPartial,
                    totalLength, newEtag, fileName);

        } else {
            throw new FileDownloadHttpException(code,
                    requestHeader, connection.getResponseHeaderFields());
        }
    }

}