public class RESTCertSecurityIT {
    public static CloseableHttpClient securedClient(String alias) throws Exception {
       ClassLoader tccl = Thread.currentThread().getContextClassLoader();
       SSLContext ctx = SSLContext.getInstance("TLS");
       JBossJSSESecurityDomain jsseSecurityDomain = new JBossJSSESecurityDomain("client_cert_auth");
       jsseSecurityDomain.setKeyStoreURL(tccl.getResource("client.keystore").getPath());
       jsseSecurityDomain.setKeyStorePassword("secret");
       jsseSecurityDomain.setClientAlias(alias);
       jsseSecurityDomain.setTrustStoreURL(tccl.getResource("truststore_client.jks").getPath());
       jsseSecurityDomain.setTrustStorePassword("secret");
       jsseSecurityDomain.reloadKeyAndTrustStore();
       KeyManager[] keyManagers = jsseSecurityDomain.getKeyManagers();
       TrustManager[] trustManagers = jsseSecurityDomain.getTrustManagers();
       ctx.init(keyManagers, trustManagers, null);
       HostnameVerifier verifier = (hostname, sslSession) -> true;
       ConnectionSocketFactory sslssf = new SSLConnectionSocketFactory(ctx, verifier);
       ConnectionSocketFactory plainsf = new PlainConnectionSocketFactory();
       Registry<ConnectionSocketFactory> sr = RegistryBuilder.<ConnectionSocketFactory>create()
               .register("http", plainsf)
               .register("https", sslssf)
               .build();
       HttpClientConnectionManager pcm = new PoolingHttpClientConnectionManager(sr);
       CloseableHttpClient httpClient = HttpClients.custom()
               .setConnectionManager(pcm)
               .build();

       return httpClient;
    }

    public void testInvalidCertificateAccess() throws Exception {
        put(securedTest2, keyAddress(KEY_A), HttpStatus.SC_FORBIDDEN);
    }

    @Ignore
    public void testSecuredReadWriteOperations() throws Exception {
        //correct alias for the certificate
        put(securedTest, keyAddress(KEY_A), HttpStatus.SC_OK);
        //test wrong authorization, 1. wrong alias for the certificate
        put(securedTest2, keyAddress(KEY_B), HttpStatus.SC_FORBIDDEN);
        //2. access over 8080
        put(securedTest, keyAddressUnsecured(KEY_B), HttpStatus.SC_UNAUTHORIZED);
        post(securedTest, keyAddress(KEY_C), HttpStatus.SC_OK);
        post(securedTest2, keyAddress(KEY_D), HttpStatus.SC_FORBIDDEN);
        //get is secured too
        HttpResponse resp = get(securedTest, keyAddress(KEY_A), HttpStatus.SC_OK);
        String content = new BufferedReader(new InputStreamReader(resp.getEntity().getContent())).readLine();
        assertEquals("data", content);
        //test wrong authorization, 1. wrong alias for the certificate
        get(securedTest2, keyAddress(KEY_A), HttpStatus.SC_FORBIDDEN);
        //2. access over 8080
        get(securedTest, keyAddressUnsecured(KEY_A), HttpStatus.SC_UNAUTHORIZED);
        head(securedTest2, keyAddress(KEY_A), HttpStatus.SC_FORBIDDEN);
        //access over 8080
        head(securedTest, keyAddressUnsecured(KEY_A), HttpStatus.SC_UNAUTHORIZED);
        head(securedTest, keyAddress(KEY_A), HttpStatus.SC_OK);
        delete(securedTest2, keyAddress(KEY_A), HttpStatus.SC_FORBIDDEN);
        delete(securedTest, keyAddress(KEY_A), HttpStatus.SC_OK);
        delete(securedTest, keyAddress(KEY_C), HttpStatus.SC_OK);
    }

    @Test
    @WithRunningServer({@RunningServer(name = CONTAINER, config = "testsuite/rest-sec-cert.xml")}

    private HttpResponse handleIOException(IOException e, int expectedCode) throws IOException {
       if ((expectedCode == HttpStatus.SC_FORBIDDEN) && ((e instanceof SSLHandshakeException) || (e instanceof SocketException)))
          return null;
       else throw e;
    }

    @AfterClass
    public static void tearDown() {
       try {
          securedTest.close();
       } catch (IOException e) {
       }
       try {
          securedTest2.close();
       } catch (IOException e) {
       }
    }

    public void testValidCertificateAccess() throws Exception {
        put(securedTest, keyAddress(KEY_A), HttpStatus.SC_OK);
    }

    @Test
    @WithRunningServer({@RunningServer(name = CONTAINER, config = "testsuite/rest-sec-cert.xml")}

    private HttpResponse put(CloseableHttpClient httpClient, String uri, int expectedCode) throws Exception {
        HttpResponse response;
        HttpPut put = new HttpPut(uri);
        put.setEntity(new StringEntity("data", "UTF-8"));
        try {
           response = httpClient.execute(put);
           assertEquals(expectedCode, response.getStatusLine().getStatusCode());
           return response;
        } catch (IOException e) {
           return handleIOException(e, expectedCode);
        }
    }

    public static void setup() throws Exception {
       securedTest = securedClient(testAlias);
       securedTest2 = securedClient(test2Alias);
    }

}