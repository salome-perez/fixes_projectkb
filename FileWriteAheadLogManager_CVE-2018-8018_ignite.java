public class FileWriteAheadLogManager {
    @Override public void release(WALPointer start) {
        assert start != null && start instanceof FileWALPointer : "Invalid start pointer: " + start;

        if (mode == WALMode.NONE)
            return;

        reservationStorage.release(((FileWALPointer)start).index());
    }


        @Override public void run() {
            Throwable err = null;

            try {
                while (!shutdown && !Thread.currentThread().isInterrupted()) {
                    while (waiters.isEmpty()) {
                        if (!shutdown)
                            LockSupport.park();
                        else {
                            unparkWaiters(Long.MAX_VALUE);

                            return;
                        }
                    }

                    Long pos = null;

                    for (Long val : waiters.values()) {
                        if (val > Long.MIN_VALUE)
                            pos = val;
                    }

                    if (pos == null)
                        continue;
                    else if (pos < UNCONDITIONAL_FLUSH) {
                        try {
                            assert pos == FILE_CLOSE || pos == FILE_FORCE : pos;

                            if (pos == FILE_CLOSE)
                                currHnd.fileIO.close();
                            else if (pos == FILE_FORCE)
                                currHnd.fileIO.force();
                        }
                        catch (IOException e) {
                            log.error("Exception in WAL writer thread: ", e);

                            err = e;

                            unparkWaiters(Long.MAX_VALUE);

                            return;
                        }

                        unparkWaiters(pos);
                    }

                    List<SegmentedRingByteBuffer.ReadSegment> segs = currentHandle().buf.poll(pos);

                    if (segs == null) {
                        unparkWaiters(pos);

                        continue;
                    }

                    for (int i = 0; i < segs.size(); i++) {
                        SegmentedRingByteBuffer.ReadSegment seg = segs.get(i);

                        try {
                            writeBuffer(seg.position(), seg.buffer());
                        }
                        catch (Throwable e) {
                            log.error("Exception in WAL writer thread: ", e);

                            err = e;
                        }
                        finally {
                            seg.release();

                            long p = pos <= UNCONDITIONAL_FLUSH || err != null ? Long.MAX_VALUE : currentHandle().written;

                            unparkWaiters(p);
                        }
                    }
                }

                unparkWaiters(Long.MAX_VALUE);
            }
            catch (Throwable t) {
                err = t;
            }
            finally {
                if (err == null && !shutdown)
                    err = new IllegalStateException("Thread " + getName() + " is terminated unexpectedly");

                if (err instanceof OutOfMemoryError)
                    cctx.kernalContext().failure().process(new FailureContext(CRITICAL_ERROR, err));
                else if (err != null)
                    cctx.kernalContext().failure().process(new FailureContext(SYSTEM_WORKER_TERMINATION, err));
            }
        }

    private void formatFile(File file, int bytesCntToFormat) throws IgniteCheckedException {
        if (log.isDebugEnabled())
            log.debug("Formatting file [exists=" + file.exists() + ", file=" + file.getAbsolutePath() + ']');

        try (FileIO fileIO = ioFactory.create(file, CREATE, READ, WRITE)) {
            int left = bytesCntToFormat;

            if (mode == WALMode.FSYNC || mmap) {
                while (left > 0) {
                    int toWrite = Math.min(FILL_BUF.length, left);

                    if (fileIO.write(FILL_BUF, 0, toWrite) < toWrite) {
                        final IgniteCheckedException ex = new IgniteCheckedException("Failed to extend WAL segment file: " +
                            file.getName() + ". Probably disk is too busy, please check your device.");

                        if (failureProcessor != null)
                            failureProcessor.process(new FailureContext(FailureType.CRITICAL_ERROR, ex));

                        throw ex;
                    }

                    left -= toWrite;
                }

                fileIO.force();
            }
            else
                fileIO.clear();
        }
        catch (IOException e) {
            throw new IgniteCheckedException("Failed to format WAL segment file: " + file.getAbsolutePath(), e);
        }
    }

}