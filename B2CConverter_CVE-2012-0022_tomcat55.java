public class B2CConverter {
    public void convert( ByteChunk bb, CharChunk cb, int limit) 
        throws IOException
    {
        iis.setByteChunk( bb );
        try {
            // read from the reader
            int bbLengthBeforeRead  = 0;
            while( limit > 0 ) {
                int size = limit < BUFFER_SIZE ? limit : BUFFER_SIZE;
                bbLengthBeforeRead = bb.getLength();
                int cnt=conv.read( result, 0, size );
                if( cnt <= 0 ) {
                    // End of stream ! - we may be in a bad state
                    if( debug>0)
                        log( "EOF" );
                    return;
                }
                if( debug > 1 )
                    log("Converted: " + new String( result, 0, cnt ));
                cb.append( result, 0, cnt );
                limit = limit - (bbLengthBeforeRead - bb.getLength());
            }
        } catch( IOException ex) {
            if( debug>0)
                log( "Reseting the converter " + ex.toString() );
            reset();
            throw ex;
        }
    }

    public  final int read() throws IOException {
        return bc.substract();
    }

    public static Charset getCharset(String enc)
            throws UnsupportedEncodingException {

        // Encoding names should all be ASCII
        String lowerCaseEnc = enc.toLowerCase(Locale.US);
        
        Charset charset = (Charset) encodingToCharsetCache.get(lowerCaseEnc);

        if (charset == null) {
            // Pre-population of the cache means this must be invalid
            throw new UnsupportedEncodingException(enc);
        }
        return charset;
    }

    void setByteChunk( ByteChunk mb ) {
        bc = mb;
    }

    public void reset()
        throws IOException
    {
        // destroy the reader/iis
        iis=new IntermediateInputStream();
        conv=new ReadConvertor( iis, getCharset(encoding) );
    }

}