public class Http11NioProtocol {
        @Override
        public SocketState process(NioChannel socket) {
            Http11NioProcessor processor = connections.remove(socket);
            try {
                if (processor == null) {
                    processor = recycledProcessors.poll();
                }
                if (processor == null) {
                    processor = createProcessor();
                }

                if (proto.isSSLEnabled() &&
                        (proto.sslImplementation != null)
                        && (socket instanceof SecureNioChannel)) {
                    SecureNioChannel ch = (SecureNioChannel)socket;
                    processor.setSslSupport(
                            proto.sslImplementation.getSSLSupport(
                                    ch.getSslEngine().getSession()));
                } else {
                    processor.setSslSupport(null);
                }

                SocketState state = processor.process(socket);
                if (state == SocketState.LONG) {
                    // In the middle of processing a request/response. Keep the
                    // socket associated with the processor.
                    connections.put(socket, processor);
                    
                    if (processor.isAsync()) {
                        NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
                        att.setAsync(true);
                        // longPoll may change socket state (e.g. to trigger a
                        // complete or dispatch)
                        state = processor.asyncPostProcess();
                    } else {
                        // Either:
                        //  - this is comet request
                        //  - the request line/headers have not been completely
                        //    read
                        SelectionKey key = socket.getIOChannel().keyFor(
                                socket.getPoller().getSelector());
                        NioEndpoint.KeyAttachment att =
                            (NioEndpoint.KeyAttachment)socket.getAttachment(false);
                        key.interestOps(SelectionKey.OP_READ);
                        att.interestOps(SelectionKey.OP_READ);
                    }
                }
                if (state == SocketState.LONG || state == SocketState.ASYNC_END) {
                    // Already done all we need to do.
                } else if (state == SocketState.OPEN){
                    // In keep-alive but between requests. OK to recycle
                    // processor. Continue to poll for the next request.
                    release(socket, processor);
                    socket.getPoller().add(socket);
                } else {
                    // Connection closed. OK to recycle the processor.
                    release(socket, processor);
                }
                return state;

            } catch (java.net.SocketException e) {
                // SocketExceptions are normal
                log.debug(sm.getString(
                        "http11protocol.proto.socketexception.debug"), e);
            } catch (java.io.IOException e) {
                // IOExceptions are normal
                log.debug(sm.getString(
                        "http11protocol.proto.ioexception.debug"), e);
            }
            // Future developers: if you discover any other
            // rare-but-nonfatal exceptions, catch them here, and log as
            // above.
            catch (Throwable e) {
                ExceptionUtils.handleThrowable(e);
                // any other exception or error is odd. Here we log it
                // with "ERROR" level, so it will show up even on
                // less-than-verbose logs.
                log.error(sm.getString("http11protocol.proto.error"), e);
            }
            release(socket, processor);
            return SocketState.CLOSED;
        }

}