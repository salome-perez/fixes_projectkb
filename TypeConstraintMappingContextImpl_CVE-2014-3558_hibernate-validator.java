public class TypeConstraintMappingContextImpl {
	@Override
	public ConstructorConstraintMappingContext constructor(Class<?>... parameterTypes) {
		Constructor<C> constructor = run( GetDeclaredConstructor.action( beanClass, parameterTypes ) );

		if ( constructor == null || constructor.getDeclaringClass() != beanClass ) {
			throw log.getBeanDoesNotContainConstructorException(
					beanClass.getName(),
					StringHelper.join( parameterTypes, ", " )
			);
		}

		if ( configuredMembers.contains( constructor ) ) {
			throw log.getConstructorHasAlreadyBeConfiguredViaProgrammaticApiException(
					beanClass.getName(),
					ExecutableElement.getExecutableAsString( beanClass.getSimpleName(), parameterTypes )
			);
		}

		ExecutableConstraintMappingContextImpl context = new ExecutableConstraintMappingContextImpl(
				this,
				constructor
		);
		configuredMembers.add( constructor );
		executableContexts.add( context );

		return context;
	}

	@Override
	public PropertyConstraintMappingContext property(String property, ElementType elementType) {
		Contracts.assertNotNull( property, "The property name must not be null." );
		Contracts.assertNotNull( elementType, "The element type must not be null." );
		Contracts.assertNotEmpty( property, MESSAGES.propertyNameMustNotBeEmpty() );

		Member member = getMember(
				beanClass, property, elementType
		);

		if ( member == null || member.getDeclaringClass() != beanClass ) {
			throw log.getUnableToFindPropertyWithAccessException( beanClass, property, elementType );
		}

		if ( configuredMembers.contains( member ) ) {
			throw log.getPropertyHasAlreadyBeConfiguredViaProgrammaticApiException( beanClass.getName(), property );
		}

		PropertyConstraintMappingContextImpl context = new PropertyConstraintMappingContextImpl(
				this,
				member
		);

		configuredMembers.add( member );
		propertyContexts.add( context );
		return context;
	}

	@Override
	public MethodConstraintMappingContext method(String name, Class<?>... parameterTypes) {
		Contracts.assertNotNull( name, MESSAGES.methodNameMustNotBeNull() );

		Method method = run( GetDeclaredMethod.action( beanClass, name, parameterTypes ) );

		if ( method == null || method.getDeclaringClass() != beanClass ) {
			throw log.getUnableToFindMethodException(
					beanClass,
					ExecutableElement.getExecutableAsString( name, parameterTypes )
			);
		}

		if ( configuredMembers.contains( method ) ) {
			throw log.getMethodHasAlreadyBeConfiguredViaProgrammaticApiException(
					beanClass.getName(),
					ExecutableElement.getExecutableAsString( name, parameterTypes )
			);
		}

		ExecutableConstraintMappingContextImpl context = new ExecutableConstraintMappingContextImpl( this, method );
		configuredMembers.add( method );
		executableContexts.add( context );

		return context;
	}

	private DefaultGroupSequenceProvider<? super C> getDefaultGroupSequenceProvider() {
		return defaultGroupSequenceProviderClass != null ? run(
				NewInstance.action(
						defaultGroupSequenceProviderClass,
						"default group sequence provider"
				)
		) : null;
	}

}