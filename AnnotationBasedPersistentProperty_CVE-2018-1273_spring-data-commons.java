public class AnnotationBasedPersistentProperty {
	private void validateAnnotation(Annotation candidate, String message, Object... arguments) {

		Class<? extends Annotation> annotationType = candidate.annotationType();

		if (!annotationType.getName().startsWith(SPRING_DATA_PACKAGE)) {
			return;
		}

		CachedValue<? extends Annotation> cachedValue = annotationCache.get(annotationType);

		if (cachedValue != null && !annotationCache.get(annotationType).value.equals(candidate)) {
			throw new MappingException(String.format(message, arguments));
		}
	}

	private final void populateAnnotationCache(Field field) {

		for (Method method : Arrays.asList(getGetter(), getSetter())) {

			if (method == null) {
				continue;
			}

			for (Annotation annotation : method.getAnnotations()) {

				Class<? extends Annotation> annotationType = annotation.annotationType();

				validateAnnotation(annotation,
						"Ambiguous mapping! Annotation %s configured "
								+ "multiple times on accessor methods of property %s in class %s!",
						annotationType.getSimpleName(), getName(), getOwner().getType().getSimpleName());

				cacheAndReturn(annotationType, AnnotatedElementUtils.findMergedAnnotation(method, annotationType));
			}
		}

		if (field == null) {
			return;
		}

		for (Annotation annotation : field.getAnnotations()) {

			Class<? extends Annotation> annotationType = annotation.annotationType();

			validateAnnotation(annotation,
					"Ambiguous mapping! Annotation %s configured " + "on field %s and one of its accessor methods in class %s!",
					annotationType.getSimpleName(), field.getName(), getOwner().getType().getSimpleName());

			cacheAndReturn(annotationType, AnnotatedElementUtils.findMergedAnnotation(field, annotationType));
		}
	}

	@Override
	public String toString() {

		if (annotationCache.isEmpty()) {
			populateAnnotationCache(field);
		}

		StringBuilder builder = new StringBuilder();

		for (CachedValue<? extends Annotation> annotation : annotationCache.values()) {
			if (annotation.value != null) {
				builder.append(annotation.value.toString()).append(" ");
			}
		}

		return builder.toString() + super.toString();
	}

	private <A extends Annotation> A cacheAndReturn(Class<? extends A> type, A annotation) {

		if (annotationCache != null) {
			annotationCache.put(type, CachedValue.of(annotation));
		}

		return annotation;
	}

	@Override
	public boolean isTransient() {

		if (this.isTransient == null) {
			boolean potentiallyTransient = super.isTransient() || isAnnotationPresent(Transient.class);
			this.isTransient = potentiallyTransient || isAnnotationPresent(Value.class)
					|| isAnnotationPresent(Autowired.class);
		}

		return this.isTransient;
	}

	@SuppressWarnings("unchecked")
	public <A extends Annotation> A findAnnotation(Class<A> annotationType) {

		Assert.notNull(annotationType, "Annotation type must not be null!");

		CachedValue<? extends Annotation> cachedAnnotation = annotationCache == null ? null
				: annotationCache.get(annotationType);

		if (cachedAnnotation != null) {
			return (A) cachedAnnotation.getValue();
		}

		for (Method method : Arrays.asList(getGetter(), getSetter())) {

			if (method == null) {
				continue;
			}

			A annotation = AnnotatedElementUtils.findMergedAnnotation(method, annotationType);

			if (annotation != null) {
				return cacheAndReturn(annotationType, annotation);
			}
		}

		return cacheAndReturn(annotationType,
				field == null ? null : AnnotatedElementUtils.findMergedAnnotation(field, annotationType));
	}

}