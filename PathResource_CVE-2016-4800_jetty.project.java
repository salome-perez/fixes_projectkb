public class PathResource {
    private final Path checkAliasPath()
    {
        Path abs = path;


        if(!URIUtil.equalsIgnoreEncodings(uri,path.toUri()))
        {
            return new File(uri).toPath().toAbsolutePath();
        }

        if (!abs.isAbsolute())
        {
            abs = path.toAbsolutePath();
        }

        try
        {
            if (Files.isSymbolicLink(path))
                return Files.readSymbolicLink(path);
            if (Files.exists(path))
            {
                Path real = abs.toRealPath(FOLLOW_LINKS);
                
                
                int absCount = abs.getNameCount();
                int realCount = real.getNameCount();
                if (absCount != realCount)
                {
                    // different number of segments
                    return real;
                }
                
                // compare each segment of path, backwards
                for (int i = realCount-1; i >= 0; i--)
                {
                    if (!abs.getName(i).toString().equals(real.getName(i).toString()))
                    {
                        return real;
                    }
                }
            }
        }
        catch (IOException e)
        {
            LOG.ignore(e);
        }
        catch (Exception e)
        {
            LOG.warn("bad alias ({} {}) for {}", e.getClass().getName(), e.getMessage(),path);
        }
        return null;
    }

    public Path getAliasPath()
    {
        return this.alias;
    }

    @Override
    public Resource addPath(final String subpath) throws IOException, MalformedURLException
    {
        String cpath = URIUtil.canonicalPath(subpath);

        if ((cpath == null) || (cpath.length() == 0))
            throw new MalformedURLException(subpath);

        if ("/".equals(cpath))
            return this;

        // subpaths are always under PathResource
        // compensate for input subpaths like "/subdir"
        // where default resolve behavior would be
        // to treat that like an absolute path

        return new PathResource(this, subpath);
    }

}