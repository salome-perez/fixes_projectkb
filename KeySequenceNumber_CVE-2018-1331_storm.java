public class KeySequenceNumber {
    public synchronized int getKeySequenceNumber(Map conf, List<ACL> defaultAcls) throws KeyNotFoundException {
        TreeSet<Integer> sequenceNumbers = new TreeSet<Integer>();
        CuratorFramework zkClient = BlobStoreUtils.createZKClient(conf, defaultAcls);
        try {
            // Key has not been created yet and it is the first time it is being created
            if (zkClient.checkExists().forPath(BLOBSTORE_SUBTREE + "/" + key) == null) {
                zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT)
                        .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE).forPath(BLOBSTORE_MAX_KEY_SEQUENCE_SUBTREE + "/" + key);
                zkClient.setData().forPath(BLOBSTORE_MAX_KEY_SEQUENCE_SUBTREE + "/" + key,
                        ByteBuffer.allocate(INT_CAPACITY).putInt(INITIAL_SEQUENCE_NUMBER).array());
                return INITIAL_SEQUENCE_NUMBER;
            }

            // When all nimbodes go down and one or few of them come up
            // Unfortunately there might not be an exact way to know which one contains the most updated blob,
            // if all go down which is unlikely. Hence there might be a need to update the blob if all go down.
            List<String> stateInfoList = zkClient.getChildren().forPath(BLOBSTORE_SUBTREE + "/" + key);
            LOG.debug("stateInfoList-size {} stateInfoList-data {}", stateInfoList.size(), stateInfoList);
            if (stateInfoList.isEmpty()) {
                return getMaxSequenceNumber(zkClient);
            }

            LOG.debug("stateInfoSize {}", stateInfoList.size());
            // In all other cases check for the latest update sequence of the blob on the nimbus
            // and assign the appropriate number. Check if all are have same sequence number,
            // if not assign the highest sequence number.
            for (String stateInfo : stateInfoList) {
                sequenceNumbers.add(Integer.parseInt(BlobStoreUtils.normalizeNimbusHostPortSequenceNumberInfo(stateInfo)
                        .getSequenceNumber()));
            }

            // Update scenario 2 and 3 explain the code logic written here
            // especially when nimbus crashes and comes up after and before update
            // respectively.
            int currentSeqNumber = getMaxSequenceNumber(zkClient);
            if (!checkIfStateContainsCurrentNimbusHost(stateInfoList, nimbusInfo) && !nimbusInfo.isLeader()) {
                if (sequenceNumbers.last() < currentSeqNumber) {
                    return currentSeqNumber;
                } else {
                    return INITIAL_SEQUENCE_NUMBER - 1;
                }
            }

            // It covers scenarios expalined in scenario 3 when nimbus-1 holding the latest
            // update goes down before it is downloaded by nimbus-2. Nimbus-2 gets elected as a leader
            // after which nimbus-1 comes back up and a read or update is performed.
            if (!checkIfStateContainsCurrentNimbusHost(stateInfoList, nimbusInfo) && nimbusInfo.isLeader()) {
                incrementMaxSequenceNumber(zkClient, currentSeqNumber);
                return currentSeqNumber + 1;
            }

            // This code logic covers the update scenarios in 2 when the nimbus-1 goes down
            // before syncing the blob to nimbus-2 and an update happens.
            // If seq-num for nimbus-2 is 2 and max-seq-number is 3 then next sequence number is 4
            // (max-seq-number + 1).
            // Other scenario it covers is when max-seq-number and nimbus seq number are equal.
            if (sequenceNumbers.size() == 1) {
                if (sequenceNumbers.first() < currentSeqNumber) {
                    incrementMaxSequenceNumber(zkClient, currentSeqNumber);
                    return currentSeqNumber + 1;
                } else {
                    incrementMaxSequenceNumber(zkClient, currentSeqNumber);
                    return sequenceNumbers.first() + 1;
                }
            }

            // Normal create update sync scenario returns the greatest sequence number in the set
            return sequenceNumbers.last();
        } catch (KeeperException.NoNodeException e) {
            // there's a race condition with a delete: either blobstore or blobstoremaxsequence
            // this should be thrown to the caller to indicate that the key is invalid now
            throw new KeyNotFoundException(key);
        } catch(Exception e) {
            // in other case, just set this to 0 to trigger re-sync later
            LOG.error("Exception {}", e);
            return INITIAL_SEQUENCE_NUMBER - 1;
        } finally {
            if (zkClient != null) {
                zkClient.close();
            }
        }
    }

}