public class AbstractMapJoin {
  protected void setupMapJoin(HiveConf hiveConf, long seed, int rowCount,
    VectorMapJoinVariation vectorMapJoinVariation, MapJoinTestImplementation mapJoinImplementation,
    String[] bigTableColumnNames, TypeInfo[] bigTableTypeInfos, int[] bigTableKeyColumnNums,
    String[] smallTableValueColumnNames, TypeInfo[] smallTableValueTypeInfos,
    int[] bigTableRetainColumnNums,
    int[] smallTableRetainKeyColumnNums, int[] smallTableRetainValueColumnNums,
    SmallTableGenerationParameters smallTableGenerationParameters) throws Exception {

    this.vectorMapJoinVariation = vectorMapJoinVariation;
    this.mapJoinImplementation = mapJoinImplementation;
    testDesc = new MapJoinTestDescription(
        hiveConf, vectorMapJoinVariation,
        bigTableColumnNames, bigTableTypeInfos,
        bigTableKeyColumnNums,
        smallTableValueColumnNames, smallTableValueTypeInfos,
        bigTableRetainColumnNums,
        smallTableRetainKeyColumnNums, smallTableRetainValueColumnNums,
        smallTableGenerationParameters);

    // Prepare data.  Good for ANY implementation variation.
    testData = new MapJoinTestData(rowCount, testDesc, seed, seed * 10);

    ObjectRegistryImpl objectRegistry = new ObjectRegistryImpl();
    ObjectCache.setupObjectRegistry(objectRegistry);
  
    operator = setupBenchmarkImplementation(
        mapJoinImplementation, testDesc, testData);

    isVectorOutput = isVectorOutput(mapJoinImplementation);

    if (!isVectorOutput) {

      bigTableRows = VectorBatchGenerateUtil.generateRowObjectArray(
          testDesc.bigTableKeyTypeInfos, testData.getBigTableBatchStream(),
          testData.getBigTableBatch(), testDesc.outputObjectInspectors);

    } else {

      bigTableBatches = VectorBatchGenerateUtil.generateBatchArray(
          testData.getBigTableBatchStream(), testData.getBigTableBatch());

    }
  }

}