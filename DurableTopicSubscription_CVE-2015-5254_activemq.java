public class DurableTopicSubscription {
    @Override
    protected MessageDispatch createMessageDispatch(MessageReference node, Message message) {
        MessageDispatch md = super.createMessageDispatch(node, message);
        if (node != QueueMessageReference.NULL_MESSAGE) {
            node.incrementReferenceCount();
            Integer count = redeliveredMessages.get(node.getMessageId());
            if (count != null) {
                md.setRedeliveryCounter(count.intValue());
            }
        }
        return md;
    }

    public void deactivate(boolean keepDurableSubsActive, long lastDeliveredSequenceId) throws Exception {
        LOG.debug("Deactivating keepActive={}, {}", keepDurableSubsActive, this);
        active.set(false);
        this.keepDurableSubsActive = keepDurableSubsActive;
        offlineTimestamp.set(System.currentTimeMillis());
        usageManager.getMemoryUsage().removeUsageListener(this);

        ArrayList<Topic> topicsToDeactivate = new ArrayList<Topic>();
        List<MessageReference> savedDispateched = null;

        synchronized (pendingLock) {
            if (!keepDurableSubsActive) {
                pending.stop();
            }

            synchronized (dispatchLock) {
                for (Destination destination : durableDestinations.values()) {
                    Topic topic = (Topic) destination;
                    if (!keepDurableSubsActive) {
                        topicsToDeactivate.add(topic);
                    } else {
                        topic.getDestinationStatistics().getInflight().subtract(dispatched.size());
                    }
                }

                // Before we add these back to pending they need to be in producer order not
                // dispatch order so we can add them to the front of the pending list.
                Collections.reverse(dispatched);

                for (final MessageReference node : dispatched) {
                    // Mark the dispatched messages as redelivered for next time.
                    if (lastDeliveredSequenceId == 0 || (lastDeliveredSequenceId > 0 && node.getMessageId().getBrokerSequenceId() <= lastDeliveredSequenceId)) {
                        Integer count = redeliveredMessages.get(node.getMessageId());
                        if (count != null) {
                            redeliveredMessages.put(node.getMessageId(), Integer.valueOf(count.intValue() + 1));
                        } else {
                            redeliveredMessages.put(node.getMessageId(), Integer.valueOf(1));
                        }
                    }
                    if (keepDurableSubsActive && pending.isTransient()) {
                        pending.addMessageFirst(node);
                        pending.rollback(node.getMessageId());
                        // not sure why pending.addMessageFirst does not take ownership of message reference
                        // by incrementing
                        node.incrementReferenceCount();
                    }
                    // createMessageDispatch increments on remove from pending for dispatch
                    node.decrementReferenceCount();
                }

                if (!topicsToDeactivate.isEmpty()) {
                    savedDispateched = new ArrayList<MessageReference>(dispatched);
                }
                dispatched.clear();
                getSubscriptionStatistics().getInflightMessageSize().reset();
            }
            if (!keepDurableSubsActive && pending.isTransient()) {
                try {
                    pending.reset();
                    while (pending.hasNext()) {
                        MessageReference node = pending.next();
                        node.decrementReferenceCount();
                        pending.remove();
                    }
                } finally {
                    pending.release();
                }
            }
        }
        for(Topic topic: topicsToDeactivate) {
            topic.deactivate(context, this, savedDispateched);
        }
        prefetchExtension.set(0);
    }

}