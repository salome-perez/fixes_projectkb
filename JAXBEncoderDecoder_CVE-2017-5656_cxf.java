public class JAXBEncoderDecoder {
    private static Object doUnmarshal(final Unmarshaller u,
                                      final Object source,
                                      final QName elName,
                                      final Class<?> clazz,
                                      final boolean unwrap) throws Exception {

        Object obj = null;
        boolean unmarshalWithClass = true;

        if (clazz == null
            || (!clazz.isPrimitive()
                && !clazz.isArray()
                && !clazz.isEnum()
                && !clazz.equals(Calendar.class)
                && (Modifier.isAbstract(clazz.getModifiers())
                    || Modifier.isInterface(clazz.getModifiers())))) {
            unmarshalWithClass = false;
        }

        if (clazz != null
            && (clazz.getName().equals("javax.xml.datatype.XMLGregorianCalendar")
                || clazz.getName().equals("javax.xml.datatype.Duration"))) {
            // special treat two jaxb defined built-in abstract types
            unmarshalWithClass = true;
        }
        if (source instanceof Node) {
            obj = unmarshalWithClass ? u.unmarshal((Node)source, clazz)
                : u.unmarshal((Node)source);
        } else if (source instanceof DepthXMLStreamReader) {
            // JAXB optimizes a ton of stuff depending on the StreamReader impl. Thus,
            // we REALLY want to pass the original reader in.   This is OK with JAXB
            // as it doesn't read beyond the end so the DepthXMLStreamReader state
            // would be OK when it returns.   The main winner is FastInfoset where parsing
            // a testcase I have goes from about 300/sec to well over 1000.

            DepthXMLStreamReader dr = (DepthXMLStreamReader)source;
            XMLStreamReader reader = dr.getReader();

            // allows the XML Stream Reader to adjust it's behaviour based on the state of the unmarshaller
            if (reader instanceof UnmarshallerAwareXMLReader) {
                ((UnmarshallerAwareXMLReader) reader).setUnmarshaller(u);
            }

            if (u.getSchema() != null) {
                //validating, but we may need more namespaces
                reader = findExtraNamespaces(reader);
            }
            obj = unmarshalWithClass ? u.unmarshal(reader, clazz) : u
                .unmarshal(dr.getReader());
        } else if (source instanceof XMLStreamReader) {
            XMLStreamReader reader = (XMLStreamReader)source;

            // allows the XML Stream Reader to adjust it's behaviour based on the state of the unmarshaller
            if (reader instanceof UnmarshallerAwareXMLReader) {
                ((UnmarshallerAwareXMLReader) reader).setUnmarshaller(u);
            }

            if (u.getSchema() != null) {
                //validating, but we may need more namespaces
                reader = findExtraNamespaces(reader);
            }
            obj = unmarshalWithClass ? u.unmarshal(reader, clazz) : u
                .unmarshal(reader);
        } else if (source instanceof XMLEventReader) {
            // allows the XML Event Reader to adjust it's behaviour based on the state of the unmarshaller
            if (source instanceof UnmarshallerAwareXMLReader) {
                ((UnmarshallerAwareXMLReader) source).setUnmarshaller(u);
            }

            obj = unmarshalWithClass ? u.unmarshal((XMLEventReader)source, clazz) : u
                .unmarshal((XMLEventReader)source);
        } else if (source == null) {
            throw new Fault(new Message("UNKNOWN_SOURCE", LOG, "null"));
        } else {
            throw new Fault(new Message("UNKNOWN_SOURCE", LOG, source.getClass().getName()));
        }
        return unwrap ? getElementValue(obj) : obj;
    }

}