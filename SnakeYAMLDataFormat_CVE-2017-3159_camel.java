public class SnakeYAMLDataFormat {
    protected Yaml getYaml(CamelContext context) {
        Yaml yaml = null;
        WeakReference<Yaml> ref = yamlCache.get();

        if (ref != null) {
            yaml = ref.get();
        }

        if (yaml == null) {
            BaseConstructor yamlConstructor = this.constructor;
            Representer yamlRepresenter = this.representer;
            DumperOptions yamlDumperOptions = this.dumperOptions;
            Resolver yamlResolver = this.resolver;
            ClassLoader yamlClassLoader = this.classLoader;
            Collection<TypeFilter> yamlTypeFilters = this.typeFilters;

            if (yamlClassLoader == null && useApplicationContextClassLoader) {
                yamlClassLoader = context.getApplicationContextClassLoader();
            }

            if (yamlConstructor == null) {
                if (allowAnyType) {
                    yamlTypeFilters = Collections.singletonList(TypeFilters.allowAll());
                }

                if (yamlTypeFilters != null) {
                    yamlConstructor = yamlClassLoader != null
                        ? typeFilterConstructor(yamlClassLoader, yamlTypeFilters)
                        : typeFilterConstructor(yamlTypeFilters);
                } else {
                    yamlConstructor = new SafeConstructor();
                }

                if (typeDescriptions != null && yamlConstructor instanceof Constructor) {
                    for (TypeDescription typeDescription : typeDescriptions) {
                        ((Constructor)yamlConstructor).addTypeDescription(typeDescription);
                    }
                }
            }
            if (yamlRepresenter == null) {
                yamlRepresenter = new Representer();

                if (classTags != null) {
                    for (Map.Entry<Class<?>, Tag> entry : classTags.entrySet()) {
                        yamlRepresenter.addClassTag(entry.getKey(), entry.getValue());
                    }
                }
            }
            if (yamlDumperOptions == null) {
                yamlDumperOptions = new DumperOptions();
                yamlDumperOptions.setPrettyFlow(prettyFlow);
            }
            if (yamlResolver == null) {
                yamlResolver = new Resolver();
            }

            yaml = new Yaml(yamlConstructor, yamlRepresenter, yamlDumperOptions, yamlResolver);
            yamlCache.set(new WeakReference<>(yaml));
        }

        return yaml;
    }

    @Override
    public void marshal(final Exchange exchange, final Object graph, final OutputStream stream) throws Exception {
        try (OutputStreamWriter osw = new OutputStreamWriter(stream, IOHelper.getCharsetName(exchange))) {
            getYaml(exchange.getContext()).dump(graph, osw);
        }
    }

    @Override
    public Object unmarshal(final Exchange exchange, final InputStream stream) throws Exception {
        try (InputStreamReader isr = new InputStreamReader(stream, IOHelper.getCharsetName(exchange))) {
            Class<?> unmarshalObjectType = unmarshalType != null ? unmarshalType : Object.class;
            return getYaml(exchange.getContext()).loadAs(isr, unmarshalObjectType);
        }
    }

    public void addTypeDescription(Class<?> type, Tag tag) {
        if (this.typeDescriptions == null) {
            this.typeDescriptions = new CopyOnWriteArrayList<>();
        }

        this.typeDescriptions.add(new TypeDescription(type, tag));
    }

    public void setUnmarshalType(Class<?> unmarshalType) {
        this.unmarshalType = unmarshalType;
        addTypeFilters(TypeFilters.types(unmarshalType));
    }

    private static Constructor typeFilterConstructor(final ClassLoader classLoader, final Collection<TypeFilter> typeFilters) {
        return new CustomClassLoaderConstructor(classLoader) {
            @Override
            protected Class<?> getClassForName(String name) throws ClassNotFoundException {
                if (typeFilters.stream().noneMatch(f -> f.test(name))) {
                    throw new IllegalArgumentException("Type " + name + " is not allowed");
                }

                return super.getClassForName(name);
            }
        };
    }

    public void setClassTags(Map<Class<?>, Tag> classTags) {
        this.classTags = new ConcurrentHashMap<>();
        this.classTags.putAll(classTags);
    }

    public void addClassTags(Class<?> type, Tag tag) {
        if (this.classTags == null) {
            this.classTags = new ConcurrentHashMap<>();
        }

        this.classTags.put(type, tag);
    }

    public void setTypeDescriptions(List<TypeDescription> typeDescriptions) {
        this.typeDescriptions = new CopyOnWriteArrayList<>(typeDescriptions);
    }

    public void addTypeDescriptions(TypeDescription... typeDescriptions) {
        addTypeDescriptions(Arrays.asList(typeDescriptions));
    }

}