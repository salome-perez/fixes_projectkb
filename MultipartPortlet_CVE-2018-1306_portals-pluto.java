public class MultipartPortlet {
   private File getFile(String fn) throws IOException {
      File tmp = null;

      String path = System.getProperty("java.io.tmpdir") + TMP;
      File dir = new File(path);
      if (!dir.exists()) {
         LOGGER.fine("Creating directory. Path: " + dir.getCanonicalPath());
         Files.createDirectories(dir.toPath());
      }
      tmp = new File(dir, fn);
      LOGGER.fine("Temp file: " + tmp.getCanonicalPath());

      return tmp;
   }

   @RenderMethod(portletNames = "MultipartPortlet")
   public void render(RenderRequest req, RenderResponse resp) throws PortletException, IOException {
      List<String> lines = new ArrayList<String>();
      @SuppressWarnings("unchecked")
      List<String> actionlines = (List<String>) req.getPortletSession().getAttribute("lines");
      if (actionlines != null) {
         lines.addAll(actionlines);
      }
      req.setAttribute("lines", lines);
      lines.add("rendering");

      String clr = req.getRenderParameters().getValue("color");
      if (clr == null) {
         clr = "#E0FFE0";
      }
      req.setAttribute("color", clr);

      // If there is a temp file, read it

      String fn = req.getRenderParameters().getValue("fn");
      String ct = req.getRenderParameters().getValue("ct");
      if ((fn == null) || (ct == null)) {
         lines.add("No file stored.");
      } else {
         StringBuilder txt = new StringBuilder(128);
         txt.append("Rendering with file: ").append(fn);
         txt.append(", type: ").append(ct);
         lines.add(txt.toString());

         List<String> flist = new ArrayList<String>();
         req.setAttribute("flist", flist);

         FileInputStream fis = null;
         BufferedReader rdr = null;
         try {
            File file = getFile(fn);
            fis = new FileInputStream(file);

            if (ct.equals("text/plain")) {
               lines.add("Processing text file.");
               if (file.length() < 2000) {
                  rdr = new BufferedReader(new InputStreamReader(fis));
                  String line;
                  while ((line = rdr.readLine()) != null) {
                     line = line.replaceAll("&", "&amp;");
                     line = line.replaceAll(" ", "&nbsp;");
                     line = line.replaceAll("<", "&lt;");
                     flist.add(line);
                  }
               } else {
                  flist.add("Sorry, file size > 2000 and is too big.");
               }
            } else if (ct.matches("image/(?:gif|jpg|jpeg)")) {
               lines.add("Processing image.");

               BufferedImage bimg = ImageIO.read(fis);
               int h = bimg.getHeight();
               int w = bimg.getWidth();

               txt.setLength(0);
               txt.append("Image height: ").append(h);
               txt.append(", width: ").append(w);
               lines.add(txt.toString());

               req.setAttribute("h", h);
               req.setAttribute("w", w);
               req.setAttribute("img", fn);

            } else {
               flist.add("Sorry, can't display this kind of file.");
            }
         } catch (Exception e) {
            flist.add("Exception preparing for render: " + e.toString());
         } finally {
            if (rdr != null) {
               rdr.close();
            } 
            if (fis != null) {
               fis.close();
            }
         }
      }

      PortletRequestDispatcher rd = req.getPortletContext().getRequestDispatcher(JSP);
      rd.include(req, resp);
   }

   public void handleDialog(ActionRequest req, ActionResponse resp) throws IOException, PortletException {
      List<String> lines = new ArrayList<String>();
      req.getPortletSession().setAttribute("lines", lines);

      lines.add("handling dialog");
      StringBuilder txt = new StringBuilder(128);

      String clr = req.getActionParameters().getValue("color");
      txt.append("Color: ").append(clr);
      lines.add(txt.toString());
      LOGGER.fine(txt.toString());

      resp.getRenderParameters().setValue("color", clr);

      txt.setLength(0);
      Part part = null;
      try {
         part = req.getPart("file");
      } catch (Throwable t) {}
      
      if ((part != null) && (part.getSubmittedFileName() != null) && 
            (part.getSubmittedFileName().length() > 0)) {
         txt.append("Uploaded file name: ").append(part.getSubmittedFileName());
         txt.append(", part name: ").append(part.getName());
         txt.append(", size: ").append(part.getSize());
         txt.append(", content type: ").append(part.getContentType());
         lines.add(txt.toString());
         LOGGER.fine(txt.toString());
         txt.setLength(0);
         txt.append("Headers: ");
         String sep = "";
         for (String hdrname : part.getHeaderNames()) {
            txt.append(sep).append(hdrname).append("=").append(part.getHeaders(hdrname));
            sep = ", ";
         }
         lines.add(txt.toString());
         LOGGER.fine(txt.toString());

         // Store the file in a temporary location in the webapp where it can be served. 
         // Note that this is, in general, not what you want to do in production, as
         // there can be problems serving the resource. Did it this way for a 
         // quick solution that doesn't require additional Tomcat configuration.

         try {
            String fn = part.getSubmittedFileName();
            File img = getFile(fn);
            if (img.exists()) {
               lines.add("deleting existing temp file: " + img.getCanonicalPath());
               img.delete();
            }
            InputStream is = part.getInputStream();
            Files.copy(is, img.toPath(), StandardCopyOption.REPLACE_EXISTING);

            resp.getRenderParameters().setValue("fn", fn);
            resp.getRenderParameters().setValue("ct", part.getContentType());

         } catch (Exception e) {
            lines.add("Exception doing I/O: " + e.toString());
            
            txt.setLength(0);
            txt.append("Problem getting temp file: " + e.getMessage() + "\n");
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            pw.flush();
            txt.append(sw.toString());
            LOGGER.warning(txt.toString());
         }
      } else {
         lines.add("file part was null");
      }

   }

   @ServeResourceMethod(portletNames="MultipartPortlet")
   public void serveImage(ResourceRequest req, ResourceResponse resp) throws IOException {
      String fn = req.getRenderParameters().getValue("fn");
      String ct = req.getRenderParameters().getValue("ct");
      
      resp.setContentType(ct);

      try {
         File file = getFile(fn);
         OutputStream os = resp.getPortletOutputStream();
         Files.copy(file.toPath(), os);
         os.flush();
      } catch (Exception e) {
         StringBuilder txt = new StringBuilder(128);
         txt.append("Problem retrieving temp file: " + e.getMessage() + "\n");
         StringWriter sw = new StringWriter();
         PrintWriter pw = new PrintWriter(sw);
         e.printStackTrace(pw);
         pw.flush();
         txt.append(sw.toString());
         LOGGER.warning(txt.toString());
      }
      
   }

}