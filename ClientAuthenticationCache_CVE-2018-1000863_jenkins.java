public class ClientAuthenticationCache {
    public @Nonnull Authentication get() {
        Jenkins h = Jenkins.getActiveInstance();
        String val = props.getProperty(getPropertyKey());
        if (val == null) {
            LOGGER.finer("No stored CLI authentication");
            return Jenkins.ANONYMOUS;
        }
        Secret oldSecret = Secret.decrypt(val);
        if (oldSecret != null) {
            LOGGER.log(Level.FINE, "Ignoring insecure stored CLI authentication for {0}", oldSecret.getPlainText());
            return Jenkins.ANONYMOUS;
        }
        int idx = val.lastIndexOf(':');
        if (idx == -1) {
            LOGGER.log(Level.FINE, "Ignoring malformed stored CLI authentication: {0}", val);
            return Jenkins.ANONYMOUS;
        }
        String username = val.substring(0, idx);
        if (!MAC.checkMac(username, val.substring(idx + 1))) {
            LOGGER.log(Level.FINE, "Ignoring stored CLI authentication due to MAC mismatch: {0}", val);
            return Jenkins.ANONYMOUS;
        }
        try {
            UserDetails u = h.getSecurityRealm().loadUserByUsername(username);
            LOGGER.log(Level.FINER, "Loaded stored CLI authentication for {0}", username);
            return new UsernamePasswordAuthenticationToken(u.getUsername(), "", u.getAuthorities());
        } catch (AuthenticationException | DataAccessException e) {
            //TODO there is no check to be consistent with User.ALLOW_NON_EXISTENT_USER_TO_LOGIN
            LOGGER.log(Level.FINE, "Stored CLI authentication did not correspond to a valid user: " + username, e);
            return Jenkins.ANONYMOUS;
        }
    }

    @VisibleForTesting
    String getPropertyKey() {
        Jenkins j = Jenkins.getActiveInstance();
        String url = j.getRootUrl();
        if (url!=null)  return url;
        
        return j.getLegacyInstanceId();
    }

}