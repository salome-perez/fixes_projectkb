public class DefaultChannel {
    @SuppressWarnings("deprecation")
    public void initChannel(ProcessorDefinition<?> outputDefinition, RouteContext routeContext) throws Exception {
        this.routeContext = routeContext;
        this.definition = outputDefinition;
        this.camelContext = routeContext.getCamelContext();

        Processor target = nextProcessor;
        Processor next;

        // init CamelContextAware as early as possible on target
        if (target instanceof CamelContextAware) {
            ((CamelContextAware) target).setCamelContext(camelContext);
        }

        // the definition to wrap should be the fine grained,
        // so if a child is set then use it, if not then its the original output used
        ProcessorDefinition<?> targetOutputDef = childDefinition != null ? childDefinition : outputDefinition;
        LOG.debug("Initialize channel for target: '{}'", targetOutputDef);

        // fix parent/child relationship. This will be the case of the routes has been
        // defined using XML DSL or end user may have manually assembled a route from the model.
        // Background note: parent/child relationship is assembled on-the-fly when using Java DSL (fluent builders)
        // where as when using XML DSL (JAXB) then it fixed after, but if people are using custom interceptors
        // then we need to fix the parent/child relationship beforehand, and thus we can do it here
        // ideally we need the design time route -> runtime route to be a 2-phase pass (scheduled work for Camel 3.0)
        if (childDefinition != null && outputDefinition != childDefinition) {
            childDefinition.setParent(outputDefinition);
        }

        // force the creation of an id
        RouteDefinitionHelper.forceAssignIds(routeContext.getCamelContext(), definition);

        // first wrap the output with the managed strategy if any
        InterceptStrategy managed = routeContext.getManagedInterceptStrategy();
        if (managed != null) {
            next = target == nextProcessor ? null : nextProcessor;
            target = managed.wrapProcessorInInterceptors(routeContext.getCamelContext(), targetOutputDef, target, next);
        }

        // then wrap the output with the backlog and tracer (backlog first, as we do not want regular tracer to tracer the backlog)
        InterceptStrategy tracer = getOrCreateBacklogTracer();
        camelContext.addService(tracer);
        if (tracer instanceof BacklogTracer) {
            BacklogTracer backlogTracer = (BacklogTracer) tracer;

            RouteDefinition route = ProcessorDefinitionHelper.getRoute(definition);
            boolean first = false;
            if (route != null && !route.getOutputs().isEmpty()) {
                first = route.getOutputs().get(0) == definition;
            }

            addAdvice(new BacklogTracerAdvice(backlogTracer, targetOutputDef, route, first));

            // add debugger as well so we have both tracing and debugging out of the box
            InterceptStrategy debugger = getOrCreateBacklogDebugger();
            camelContext.addService(debugger);
            if (debugger instanceof BacklogDebugger) {
                BacklogDebugger backlogDebugger = (BacklogDebugger) debugger;
                addAdvice(new BacklogDebuggerAdvice(backlogDebugger, target, targetOutputDef));
            }
        }

        if (routeContext.isMessageHistory()) {
            // add message history advice
            MessageHistoryFactory factory = camelContext.getMessageHistoryFactory();
            addAdvice(new MessageHistoryAdvice(factory, targetOutputDef));
        }

        // the regular tracer is not a task on internalProcessor as this is not really needed
        // end users have to explicit enable the tracer to use it, and then its okay if we wrap
        // the processors (but by default tracer is disabled, and therefore we do not wrap processors)
        tracer = getOrCreateTracer();
        camelContext.addService(tracer);
        if (tracer != null) {
            TraceInterceptor trace = (TraceInterceptor) tracer.wrapProcessorInInterceptors(routeContext.getCamelContext(), targetOutputDef, target, null);
            // trace interceptor need to have a reference to route context so we at runtime can enable/disable tracing on-the-fly
            trace.setRouteContext(routeContext);
            target = trace;
        }

        // sort interceptors according to ordered
        interceptors.sort(new OrderedComparator());
        // then reverse list so the first will be wrapped last, as it would then be first being invoked
        Collections.reverse(interceptors);
        // wrap the output with the configured interceptors
        for (InterceptStrategy strategy : interceptors) {
            next = target == nextProcessor ? null : nextProcessor;
            // skip tracer as we did the specially beforehand and it could potentially be added as an interceptor strategy
            if (strategy instanceof Tracer) {
                continue;
            }
            // skip stream caching as it must be wrapped as outer most, which we do later
            if (strategy instanceof StreamCaching) {
                continue;
            }
            // use the fine grained definition (eg the child if available). Its always possible to get back to the parent
            Processor wrapped = strategy.wrapProcessorInInterceptors(routeContext.getCamelContext(), targetOutputDef, target, next);
            if (!(wrapped instanceof AsyncProcessor)) {
                LOG.warn("Interceptor: " + strategy + " at: " + outputDefinition + " does not return an AsyncProcessor instance."
                        + " This causes the asynchronous routing engine to not work as optimal as possible."
                        + " See more details at the InterceptStrategy javadoc."
                        + " Camel will use a bridge to adapt the interceptor to the asynchronous routing engine,"
                        + " but its not the most optimal solution. Please consider changing your interceptor to comply.");

                // use a bridge and wrap again which allows us to adapt and leverage the asynchronous routing engine anyway
                // however its not the most optimal solution, but we can still run.
                InterceptorToAsyncProcessorBridge bridge = new InterceptorToAsyncProcessorBridge(target);
                wrapped = strategy.wrapProcessorInInterceptors(routeContext.getCamelContext(), targetOutputDef, bridge, next);
                // Avoid the stack overflow
                if (!wrapped.equals(bridge)) {
                    bridge.setTarget(wrapped);
                } else {
                    // Just skip the wrapped processor
                    bridge.setTarget(null);
                }
                wrapped = bridge;
            }
            if (!(wrapped instanceof WrapProcessor)) {
                // wrap the target so it becomes a service and we can manage its lifecycle
                wrapped = new WrapProcessor(wrapped, target);
            }
            target = wrapped;
        }

        if (routeContext.isStreamCaching()) {
            addAdvice(new StreamCachingAdvice(camelContext.getStreamCachingStrategy()));
        }

        if (routeContext.getDelayer() != null && routeContext.getDelayer() > 0) {
            addAdvice(new DelayerAdvice(routeContext.getDelayer()));
        }

        // sets the delegate to our wrapped output
        output = target;
    }

}