public class XmlSecInInterceptor {
    private void prepareMessage(Message inMsg) throws Fault {
        
        XMLStreamReader originalXmlStreamReader = inMsg.getContent(XMLStreamReader.class);
        if (originalXmlStreamReader == null) {
            InputStream is = inMsg.getContent(InputStream.class);
            if (is != null) {
                originalXmlStreamReader = StaxUtils.createXMLStreamReader(is);
            }
        }

        try {
            XMLSecurityProperties properties = new XMLSecurityProperties();
            configureDecryptionKeys(inMsg, properties);
            Crypto signatureCrypto = getSignatureCrypto(inMsg);
            configureSignatureKeys(signatureCrypto, inMsg, properties);

            SecurityEventListener securityEventListener =
                configureSecurityEventListener(signatureCrypto, inMsg, properties);
            InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);

            XMLStreamReader newXmlStreamReader =
                inboundXMLSec.processInMessage(originalXmlStreamReader, null, securityEventListener);
            inMsg.setContent(XMLStreamReader.class, newXmlStreamReader);

        } catch (XMLStreamException e) {
            throwFault(e.getMessage(), e);
        } catch (XMLSecurityException e) {
            throwFault(e.getMessage(), e);
        } catch (IOException e) {
            throwFault(e.getMessage(), e);
        } catch (UnsupportedCallbackException e) {
            throwFault(e.getMessage(), e);
        }
    }

    private boolean isServerGet(Message message) {
        String method = (String)message.get(Message.HTTP_REQUEST_METHOD);
        return "GET".equals(method) && !MessageUtils.isRequestor(message);
    }

    @Override
    public Object aroundReadFrom(ReaderInterceptorContext ctx) throws IOException, WebApplicationException {
        Message message = JAXRSUtils.getCurrentMessage();    
        if (isServerGet(message)) {
            return ctx.proceed();    
        } else {
            prepareMessage(message);
            Object object = ctx.proceed();
            new StaxActionInInterceptor(requireSignature, 
                                        requireEncryption).handleMessage(message);
            return object;
        }
        
    }

        @Override
        public void handleMessage(Message message) throws Fault {

            if (!(signatureRequired || encryptionRequired)) {
                return;
            }

            @SuppressWarnings("unchecked")
            final List<SecurityEvent> incomingSecurityEventList =
                (List<SecurityEvent>)message.get(SecurityEvent.class.getName() + ".in");

            if (incomingSecurityEventList == null) {
                LOG.warning("Security processing failed (actions mismatch)");
                XMLSecurityException ex =
                    new XMLSecurityException("empty", new Object[] {"The request was not signed or encrypted"});
                throwFault(ex.getMessage(), ex);
            }

            if (signatureRequired) {
                Event requiredEvent = SecurityEventConstants.SignatureValue;
                if (!isEventInResults(requiredEvent, incomingSecurityEventList)) {
                    LOG.warning("The request was not signed");
                    XMLSecurityException ex =
                        new XMLSecurityException("empty", new Object[] {"The request was not signed"});
                    throwFault(ex.getMessage(), ex);
                }
            }

            if (encryptionRequired) {
                boolean foundEncryptionPart =
                    isEventInResults(SecurityEventConstants.EncryptedElement, incomingSecurityEventList);
                if (!foundEncryptionPart) {
                    LOG.warning("The request was not encrypted");
                    XMLSecurityException ex =
                        new XMLSecurityException("empty", new Object[] {"The request was not encrypted"});
                    throwFault(ex.getMessage(), ex);
                }
            }

        }

}