public class LauncherServerSuite {
  private void waitForError(TestClient client, String secret) throws Exception {
    boolean helloSent = false;
    int maxTries = 10;
    for (int i = 0; i < maxTries; i++) {
      try {
        if (!helloSent) {
          client.send(new Hello(secret, "1.4.0"));
          helloSent = true;
        } else {
          client.send(new SetAppId("appId"));
        }
        fail("Expected error but message went through.");
      } catch (IllegalStateException | IOException e) {
        // Expected.
        break;
      } catch (AssertionError e) {
        if (i < maxTries - 1) {
          Thread.sleep(100);
        } else {
          throw new AssertionError("Test failed after " + maxTries + " attempts.", e);
        }
      }
    }
  }

  @Test
  public void testTimeout() throws Exception {
    ChildProcAppHandle handle = null;
    TestClient client = null;
    try {
      // LauncherServer will immediately close the server-side socket when the timeout is set
      // to 0.
      SparkLauncher.setConfig(SparkLauncher.CHILD_CONNECTION_TIMEOUT, "0");

      handle = LauncherServer.newAppHandle();

      Socket s = new Socket(InetAddress.getLoopbackAddress(),
        LauncherServer.getServerInstance().getPort());
      client = new TestClient(s);
      waitForError(client, handle.getSecret());
    } finally {
      SparkLauncher.launcherConfig.remove(SparkLauncher.CHILD_CONNECTION_TIMEOUT);
      kill(handle);
      close(client);
    }
  }

  @Test
  public void testStreamFiltering() throws Exception {
    ChildProcAppHandle handle = LauncherServer.newAppHandle();
    TestClient client = null;
    try {
      Socket s = new Socket(InetAddress.getLoopbackAddress(),
        LauncherServer.getServerInstance().getPort());

      client = new TestClient(s);
      client.send(new EvilPayload());
      waitForError(client, handle.getSecret());
      assertEquals(0, EvilPayload.EVIL_BIT);
    } finally {
      kill(handle);
      close(client);
      client.clientThread.join();
    }
  }

}