public class View{
    private boolean filterQueueItemTest(Queue.Item item, Collection<TopLevelItem> viewItems) {
        // Check if the task of parent tasks are in the list of viewItems.
        // Pipeline jobs and other jobs which allow parts require us to
        // check owner tasks as well.
        Queue.Task currentTask = item.task;
        for (int count = 1;; count++) {
            if (viewItems.contains(currentTask)) {
                return true;
            }
            Queue.Task next = currentTask.getOwnerTask();
            if (next == currentTask) {
                break;
            } else {
                currentTask = next;
            }
            if (count == FILTER_LOOP_MAX_COUNT) {
                LOGGER.warning(String.format(
                        "Failed to find root task for queue item '%s' for " +
                        "view '%s' in under %d iterations, aborting!",
                        item.getDisplayName(), getDisplayName(),
                        FILTER_LOOP_MAX_COUNT));
                break;
            }
        }
        // Check root project for sub-job projects (e.g. matrix jobs).
        if (item.task instanceof AbstractProject<?, ?>) {
            AbstractProject<?,?> project = (AbstractProject<?, ?>) item.task;
            if (viewItems.contains(project.getRootProject())) {
                return true;
            }
        }
        return false;
    }
    private List<Queue.Item> filterQueue(List<Queue.Item> base) {
        if (!isFilterQueue()) {
            return base;
        }
        Collection<TopLevelItem> items = getItems();
        return base.stream().filter(qi -> filterQueueItemTest(qi, items))
                .collect(Collectors.toList());
    }
    public void updateByXml(Source source) throws IOException {
        checkPermission(CONFIGURE);
        StringWriter out = new StringWriter();
        try {
            // this allows us to use UTF-8 for storing data,
            // plus it checks any well-formedness issue in the submitted
            // data
            XMLUtils.safeTransform(source, new StreamResult(out));
            out.close();
        } catch (TransformerException|SAXException e) {
            throw new IOException("Failed to persist configuration.xml", e);
        }

        // try to reflect the changes by reloading
        try (InputStream in = new BufferedInputStream(new ByteArrayInputStream(out.toString().getBytes("UTF-8")))){
            // Do not allow overwriting view name as it might collide with another
            // view in same ViewGroup and might not satisfy Jenkins.checkGoodName.
            String oldname = name;
            ViewGroup oldOwner = owner; // oddly, this field is not transient
            Object o = Jenkins.XSTREAM2.unmarshal(XStream2.getDefaultDriver().createReader(in), this, null, true);
            if (!o.getClass().equals(getClass())) {
                // ensure that we've got the same view type. extending this code to support updating
                // to different view type requires destroying & creating a new view type
                throw new IOException("Expecting view type: "+this.getClass()+" but got: "+o.getClass()+" instead." +
                    "\nShould you needed to change to a new view type, you must first delete and then re-create " +
                    "the view with the new view type.");
            }
            name = oldname;
            owner = oldOwner;
        } catch (StreamException | ConversionException | Error e) {// mostly reflection errors
            throw new IOException("Unable to read",e);
        }
        save();
    }
}